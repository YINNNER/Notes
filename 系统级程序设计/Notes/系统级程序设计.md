# 系统级程序设计

>笔记转载改编自：软软笔记、ppt、教材
>
>教材：《深入理解计算机系统》（原书第三版）
>
>考试范围：教材第1、2、3、5章
>
>资料：ppt+教材+教材习题
>
>ppt重点：程序逻辑、公式、练习
>
>考试题型：
>
>1. 选择/判断题 10’
>2. 简答题 40’-50’
>3. 分析题40’



# 1 概述

## 5大事实

### 1. Ints不是整数，Floats不是实数

#### 溢出问题

Example 1: Is $x^2$ ≥ 0?

- Float’s: Yes! 

- Int’s:
  - 40000 * 40000 --> 1600000000 
  - 50000 * 50000 --> ? 

#### 误差问题

Example 2: Is (x + y) + z = x + (y + z)?

- Unsigned & Signed Int’s: Yes!

-  Float’s: 
  - (1e20 + -1e20) + 3.14 --> 3.14 
  - 1e20 + (-1e20 + 3.14) --> ?? 

#### 计算机算术运算

- 不能产生真正的随机数

- 算术运算有很多性质，但是由于计算机只能表示有限的数字，所以在计算机中并不是都满足：

  - 整数运算满足“ring”性质：交换律、结合律、分配律
  - 浮点数运算满足次序的性质：单调性、符号不变

- Cannot assume all “usual” mathematical properties 

  - Due to finiteness of representations

  - Integer operations satisfy “ring” properties 

    - Commutativity, associativity, distributivity

  - Floating point operations satisfy “ordering” properties
    - Monotonicity, values of signs 

### 2. 需要了解汇编语言

了解汇编语言是机器指令执行模型的关键。

- 存在错误的程序行为
  - 高级语言模型崩溃
- 优化程序性能
  - 了解编译器完成/未完成的优化
  - 了解程序不高效的原因
- 实现系统软件
  - 编译器将机器代码作为目标
  - 操作系统必须管理进程状态
- 创建/对抗恶意软件
  - x86汇编是首选语言
- Behavior of programs in presence of bugs
  - High-level language models break down 
- Tuning program performance
  - Understand optimizations done / not done by the compiler
  - Understanding sources of program inefficiency 
- Implementing system software
  - Compiler has machine code as target
  - Operating systems must manage process state 
- Creating / fighting malware 
  - x86 assembly is the language of choice! 

### 3. 内存很重要

随机访问存储器是一种非物理的抽象。

- 内存不是无限的
  - 必须进行分配和管理
  - 许多应用程序都很占内存
- 内存引用错误特别有害
  - 在时间和空间上影响都是不好的
- 内存性能不统一
  - 缓存和虚拟内存效应会极大地影响程序性能
  - 使程序适应存储器系统的特性可以大大提高速度
- Memory is not unbounded
  - It must be allocated and managed
  - Many applications are memory dominated 
- Memory referencing bugs especially pernicious
  - Effects are distant in both time and space 
- Memory performance is not uniform 
  - Cache and virtual memory effects can greatly affect program performance 
  - Adapting program to characteristics of memory system can lead to major speed improvements 

#### 内存引用Bug例子（重点）

![](系统级复习.assets/01-1.png)

![](系统级复习.assets/01-2.png)

解释：

- int 4字节，double 8字节，因此一个double相当于两个int，即a[2], a[3]都是double d的内存位置。
- 注意，栈是向低地址(高处)生长，但是一个数据类型的高位字节在低地址，低位字节在高地址，因此a[2]对应double的0-3低位字节，修改a[2]只影响到了double值的小数位；a[3]对应double的4-7高位字节，修改a[3]影响到了double值的整数位。

#### 内存引用错误

- C和C++不提供内存保护
  - 数组越界
  - 无效的指针值
  - malloc/free滥用
- 会导致严重的bugs
  - 错误是否有效取决于系统和编译器
  - bug总是很晚才发现
    - 损坏的对象在逻辑上与正在访问的对象无关
    - 可能会在生成错误后很长时间内观察到错误的影响
- 如何解决
  - 用高级语言写程序
  - 了解可能发生的交互
  - 使用或开发工具来检测引用错误

-  C and C++ do not provide any memory protection
  - Out of bounds array references
  - Invalid pointer values
  - Abuses of malloc/free 

- Can lead to nasty bugs
  - Whether or not bug has any effect depends on system and compiler
  - Action at a distance 
    - Corrupted object logically unrelated to one being accessed
    - Effect of bug may be first observed long after it is generated 

- How can I deal with this?
  - Program in Java, Ruby, Python, ML, ... 
  - Understand what possible interactions may occur
  - Use or develop tools to detect referencing errors (e.g. Valgrind) 

### 4. 性能比渐近复杂性更重要

- 常数因子也很重要
- 即使知道精确的操作步骤也不能预测性能
  - 根据编写代码的方式，性能会在10：1的范围浮动
  - 必须在多个级别进行优化：算法，数据表示，过程和循环
- 要优化性能必须理解系统
  - 程序是怎么编译和执行的
  - 如何测量程序性能并且识别瓶颈
  - 如何在不破坏代码模块化和普遍性的条件下提高性能

- Constant factors matter too! 
- And even exact op count does not predict performance
  - Easily see 10:1 performance range depending on how code written 
  - Must optimize at multiple levels: algorithm, data representations, procedures, and loops 
- Must understand system to optimize performance 
  - How programs compiled and executed 
  - How to measure program performance and identify bottlenecks 
  -  How to improve performance without destroying code modularity and generality 

#### 内存系统性能例子（重点）

两种嵌套循环访问二维数组的性能差别。

![](系统级复习.assets/01-3.png)

### 5. 计算机除了执行程序还要做很多别的

- 计算机需要进行数据的输入和输出
  - I/O系统对程序的可靠性和性能很重要
- 计算机通过网络互相交流
  - 很多系统级别的问题发生在网络中
    - 自主进程的并发操作
    - 与不可靠的媒体通信
    - 跨平台兼容性
    - 复杂的性能问题

- They need to get data in and out 
  - I/O system critical to program reliability and performance 

- They communicate with each other over networks
  - Many system-level issues arise in presence of network 
    - Concurrent operations by autonomous processes
    - Coping with unreliable media
    - Cross platform compatibility
    - Complex performance issues 

## 1.1 信息就是位+上下文

- 系统中所有的信息——包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。
- 区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。比如，在不同的上下文中，一个同样的字节序列可能表示一个整数、浮点数、字符串或者机器指令。

## 1.2 程序被其他程序翻译成不同的格式

编译系统。

![](系统级复习.assets/01-4.png)

### 预处理阶段

预处理器(cpp) 根据以字符＃开头的命令，修改原始的 C 程序。比如hello.c中第1行的`#include<stdio.h>` 命令告诉预处理器读取系统头文件`stdio.h` 的内容，并把它直接插入程序文本中。结果就得到了另一个C程序，通常是以`.i`作为文件扩展名。

### 编译阶段

编译器(ccl)将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序。程序中每条语句都以一种文本格式描述了一条低级机器语言指令。汇编语言是非常有用的，因为它为不同高级语言的不同编译器提供了通用的输出语言。

### 汇编阶段

接下来，汇编器(as)将hello.s翻译成机器语言指令，把这些指令打包成一种叫做**可重定位目标程序( relocatable object program)** 的格式，并将结果保存在目标文件 hello.o中。hello.o文件是一个二进制文件，它包含的 17 个字节是函数main的指令编码。如果我们在文本编辑器中打开hello.o文件，将看到一堆乱码。

### 链接阶段

请注意，hello程序调用了printf 函数，它是每个C编译器都提供的标准C库中的一个函数。printf 函数存在于一个名为printf.o 的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的hello.o 程序中。链接器(Id) 就负责处理这种合并。结果就得到hello 文件，它是一个可执行目标文件（或者简称为可执行文件），可以被加载到内存中，由系统执行。

## 1.3 了解编译系统如何工作是大有益处的

必须了解编译系统是如何工作的原因：

- 优化程序性能。
- 理解链接时出现的错误。
- 避免安全漏洞。

## 1.4 处理器读并解释储存在内存中的指令

主要是讲系统的硬件组成，略。

我们将处理器的指令集架构和处理器的微体系结构区分开来：

- 指令集架构描述的是每条机器代码指令的效果；
- 而微体系结构描述的是处理器实际上是如何实现的。

## 1.5 高速缓冲至关重要

意识到高速缓存存储器存在的应用程序员能够利用高速缓存将程序的性能提高一个数量级。

## 1.6 存储设备形成层次结构

在这个层次结构中，从上至下，设备的访问速度越来越慢、容最越来越大，并且每字节的造价也越来越便宜。寄存器文件在层次结构中位于最顶部，也就是第0级或记为L0 。这里我们展示的是三层高速缓存L1到L3 , 占据存储器层次结构的第 1 层到第 3 层。主存在第 4 层，以此类推。

**存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。**因此，寄存器文件就是 L1 的高速缓存，L1是 L2 的高速缓存，L2 是 L3 的高速缓存，L3 是主存的高速缓存，而主存又是磁盘的高速缓存。在某些具有分布式文件系统的网络系统中 ，本地磁盘就是存储在其他系统中磁盘上的数据的高速缓存。

正如可以运用不同的高速缓存的知识来提高程序性能一样，程序员同样可以利用对整       个存储器层次结构的理解来提高程序性能。

![](系统级复习.assets/01-5.png)

## 1.7 操作系统管理硬件

操作系统有两个基本功能：

1. 防止硬件被失控的应用程序滥用；
2. 向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。操作系统通过几个基本的抽象概念（进程、虚拟内存和文件）来实现这两个功能。

- 文件：I/O 设备的抽象表示。
- 虚拟内存：是对主存和磁盘 I/O 设备的抽象表示。
- 进程则是对处理器、主存和 I/O 设备的抽象表示。

后面就是讲文件、虚拟内存、进程。

### 1.7.1 进程

略。

注意，内核不是一个独立的进程。相反，它是系统管理全部进程所用的**代码和数据结构的集合。**

### 1.7.2 线程

略。

### 1.7.3 虚拟内存

虚拟内存是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用   主存。每个进程看到的内 存都是一致的，称为虚拟地址空间 。下图所示的是 Linux 进程的虚拟地址空间（其他 Unix 系统的设计也与此类似）。在Linux 中，地址空间最上面的区域是保留给操作系统中的代码和数据的，这对所有进程来说都是一样。地址空间的底部区域存放用户进程定义的代码和数据。请注意，图中的地址是从下往上增大的。

每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能。我们从最低的地址开始，逐步向上介绍。

1. 程序代码和数据。对所有的进程来说，代码是从同一固定地址开始，紧接着的是和C 全局变量相对应的数据位置。代码和数据区 是直接按照可 执行目标文件的内容初始化的，在示例中就是可执行文件hello 。
2. 堆。代码和数据区后紧随着的是运行时堆。代码和数据区在进程一开始运行时就被       指定了大小，与此不同，当调用像malloc和free这样的 C 标准库函数时 ，堆可以在运行时动态地扩展和收缩 。
3. 共享库。大约在地址空间的中间部分是一块用来存放像 C 标准库和数学库这样的共享库的代码和数据的区域。
4. 栈。位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数调用。和堆一        样，用户栈在程序执行期间可以动态地扩展和收缩。特别地，每次我们调用一个函数时，栈就会增长；从一个函数返回时，栈就会收缩。
5. 内核虚拟内存。地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反，它们必须调用内核来执行这些操作。

![](系统级复习.assets/01-6.png)

### 1.7.4 文件

文件就是字节序列，仅此而已。每个I/O设备，包括磁盘、键盘、显示器，甚至网络，都 可以看成是文件。系统中的所有输入输出都是通过使用一小组称为Unix I/O的系统函数调用读写文件来实现的。

## 1.8 系统之间利用网络通信

略。

## 1.9 重要主题

### 1.9.1 Amdahl定律（重点）

Gene Amdahl,  计算领域的早期先锋之一 ，对提升系统某一部分性能所带来的效果 做出了简单却有见地的观察。这个观察被称为 Amdahl定律( Amdahl' s law) 。该定律的主要思想是，当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度 。若系统执行某应用程序需要时间为$T_{old}$ 。 假设系统某部分所需执行时间与该时间的比例为$\alpha$ , 而该部分性能提升比例为$k$。 即该部分初始所需时间为$\alpha T_{old}$ ,  现在所需时间为$(\alpha T_{old})/k$。因 此，总的执行时间应为
$$
T_{new} = (1-\alpha) T_{old} + (\alpha T_{old})/k = T_{old}[(1-\alpha)+\alpha/k]
$$
由此 ，可以计算加速比$S = T_{old}/ T_{new}$ 为
$$
S = \frac{1}{(1-\alpha)+\alpha/k}
$$
举个例子，考虑这样一种情况，系统的某个部分初始耗时比例为 60% ($\alpha = 0.6$), 其加速比例因子为3(k= 3) 。则我们可以获得的加速比为 $1/ [0.4+0.6/3]=1. 67$ 倍。**虽然我们对系统的一个主要部分做出了重大改进，但是获得的系统加速比却明显小于这部分的加速比。这就是Amdahl 定律的主要观点—— 要想显著加速整个系统，必须提升全系统中相当大的部分的速度。**

Amdahl 定律一个有趣的特殊情况是考虑 k 趋向$\infty$ 时的效果。这就意味着 ，我们可以取系统的某一部分将其加速到一个点，在这个点上，这部分花费的时间可以忽略不计。于是我们得到
$$
S_{\infty}=\frac{1}{(1-\alpha)}
$$
举个例子，如果60%的系统能够加速到不花时间的程度，我们获得的净加速比将仍只有1/0.4=2.5X。

Amdahl定律描述了改善任何过程的一般原则。也许它在计算机世界里是最有意义的，在这里我们常常把性能提升2倍或更高的比例因子。这么高的比例因子只有通过优化系统的大部分组件才能获得。

### 1.9.2 并发和并行

略。

多核处理器：是将多个CPU(称为“核”)集成到一个集成电路芯片上。下图描述的是一个典型多核处理器的组织结构，其中微处理器芯片有 4 个CPU核，每个核都有自己的 L1 和L2高速缓存，其中的 L1高速缓存分为两个部分——一个保存最近取到的指令，另一个存放数据。这些核共享更高层次的高速缓存，以及到主存的接口。

![](系统级复习.assets/01-7.png)

#### 1.9.3 计算机系统中抽象的重要性

我们已经介绍了计算机系统中使用的几个抽象 ，如图所示。

在处理器里，指令集架构提供了对实际处理器硬件的抽象。使用这个抽象，机器代码程序表现得就好像运行在一个一次只执行一条指令的处理器上。底层的硬件远 比抽象 描述的要复杂 精细，它并行地执行多条指令，但又总是与那个简单有序的模型保持一致。只要执行模型一样，不同的处理器实现也能执行同样的机器代码，而又提供不同的开销和性能。

虚拟机：它提供对整个计算机的抽象，包括操作系统、处理器和程序。虚拟机的思想是IBM 在 20 世纪 60 年代提出来 的，但是最近才显示出其管理计算机方式上的优势，因为一些计算机必须能够运行为不同的操作系统（例如，Microsoft Windows、MacOS 和Linux) 或同一操作系统的不同版本设计的程序。

![](系统级复习.assets/01-8.png)

# 2 信息的表示与处理

## 2.1 信息存储

大部分计算机使用字节作为最小的可寻址的内存单位，而不是访问内存中单独的位。内存的每个字节都由一个唯一的数字来标识，称为它的地址，所有可能地址的集合就称为虚拟地址空间(virtual address space)。

### 2.1.1 十六进制表示法

- 十六进制数（hexadecimal）
- 表示
- 在C语言中，以0x或0X开头的数字常量被认为是十六进制的值，字母可大写、小写、甚至大小写混合。
- 与二进制、十进制之间的转换（十进制转k进制：除k取余法（倒着取余数））

### 2.1.2 字数据大小

- 每台计算机都有一个字长(word size)，指明指针数据的标称大小(nominal size)
  - 对于一个字长为$w$位的及其而言，虚拟地址的范围为$0\sim 2^w-1$
  - 32位字长机器，64位字长机器
  - 将程序称为“32位程序”或“64位程序”时，区别在于该程序是如何编译的，而不是其运行的机器类型。
    - 32位程序可在32位或64位机器上运行。编译`gcc -m32 prog.c`。
    - 64位程序只能在64位机器上运行。编译`gcc -m64 prog.c`。
- 为了避免由于依赖“典型”大小和不同编译器设置带来的奇怪行为，ISO C99引入了一类数据类型，其大小是固定的，不随编译器和机器设置而变化。其中就有数据类型int32_t和int64_t，他们分别为4个字节和8个字节。使用确定大小的整数类型是程序员准确控制数据表示的最佳途径。

![1545747230200](系统级复习.assets/1545747230200.png)



### 2.1.3 寻址和字节顺序

（03-bits-ints-part2 P.32）

- 多字节对象被存储为连续的字节序列，对象的地址为所使用字节中最小的地址

  - 如：假设一个类型为int（32位表示）的变量x的地址为0x100，即&x=0x100，那么x的4个字节将被存储在内存的0x100, 0x101,0x102, 0x103

- 排列一个对象的字节的两个通用的规则：

  - 大端法：在内存中，按照从最高有效字节到最低有效字节的顺序存储对象，即最高有效字节在最前面的方式。

    - 假设int变量x，位于地址0x100，十六进制为0x01234567：

    ![1545840157393](系统级复习.assets/1545840157393.png)

    - 使用大端的处理器：Sun（Oracle SPARC），PPC Mac，Internet

  - 小端法：在内存中，按照从最低有效字节到最高有效字节的顺序存储对象，即最低有效字节在最前面(低地址)的方式。

    ![1545840204238](系统级复习.assets/1545840204238.png)

    - 使用小端的处理器：x86，在Android、iOS和Linux上运行的ARM处理器

  - 许多新的微处理器是双端法：即可以把它们配置成作为大端或小端的机器运行。

- 强制类型转换运算符可将一种数据类型转换为另一种，它不会改变真实的指针，只是告诉编译器以新的数据类型来看待被指向的数据。

### 2.1.4 表示字符串

（03-bits-ints-part2 P.42）

- C语言中字符串被编码为一个以null（其值为0）字符结尾的字符数组，每个字符都由标准编码来表示，最常见是ASCII字符码。
  - 0对应的ascii码为：0x30
  - 数字i的ascii码为：0x30+i
  - 终止字节：0x00

### 2.1.5 表示代码

（03-bits-ints-part2 P.43）

- 不同的机器类型使用不同的且不兼容的指令和编码方式
- 二进制代码是不兼容的，很少能在不同机器和操作系统组合之间移植
- 计算机系统的一个基本概念就是：从机器的角度来看，程序仅仅只是字节序列。机器没有关于原始源程序的任何信息，除了可能有些用来帮助调试的辅助表以外。

### 2.1.6 布尔代数

- 布尔代数运算：and（&）、or（|）、not（~）、Xor（^）

![1545747573711](系统级复习.assets/1545747573711.png)

### 2.1.7 C语言中的位级运算

- 位级布尔运算：and（&）、or（|）、not（~）、Xor（^）
- 常用于实验掩码运算。这里掩码是一个位模式，表示从一个字中选出的位的集合。

### 2.1.8 C语言逻辑运算

- 逻辑运算认为==所有非零==的参数都表示TRUE，参数0表示FALSE，返回1或0。

![1545748005447](系统级复习.assets/1545748005447.png)

- 逻辑运算和对应的位级运算的另一个区别是：如果对第一个参数求值就可以确定表达式的结果，那么逻辑运算符就不会对第二个参数求值。==即逻辑运算有短路运算，但是位级运算没有！==
  - 表达式a&&5/a不会造成被0除，p&&p++不会导致间接引用空指针。

### 2.1.9 C语言移位运算

- 移位运算是**从左到右**可结合的
  - x<<j<<k等价于：(x<<j)<<k
- 左移`x<<y`：向左移动k位，丢弃最高的k位，并在右端补k个0。
- 右移`x>>y`：分为逻辑右移(Logical shift)和算术右移(Arithmetic shift)。
  - 逻辑右移：在左端补k个0。
  - **算术右移**：在左端补**k个最高有效位的值**（有符号整数数据很有用）。

![1545748775486](系统级复习.assets/1545748775486.png)

- C语言没有明确定义对有符号数使用哪种类型的右移，但几乎所有的编译器/机器组合都对有符号数使用算术右移。
- 对无符号数，右移必须是逻辑的。
- 加法（减法）优先级比移位运算高。
  - 1<<2+3<<4 等价于 (1<< (2+3))<<4

#### 特殊情况1：移动位数大于数据位数

假设移动k位，数据是w位的，则实际上的位移量`k mod w`（有点类似于循环移动）。

![1545748960566](系统级复习.assets/1545748960566.png)



#### 特殊情况2: 移动位数是负数

当$k\le0 $位时，左右移位只看k的二进制的最后5位（32位系统）。

其实就是将负数转换为对应的无符号正数，再`k mod w`。

```C++
int a = 15;
int b = a<<-1;
int c = a<<-2;

/*
输出：
a = 000000000000000000000000000001111
b = 100000000000000000000000000000000（-1的最后五位为11111，所以左移31位）
c = 110000000000000000000000000000000（-2的最后五位为11110，所以左移30位）
*/
```


## 2.2 整数表示

### 2.2.1 整型数据类型

- 32位及其上各类型整型数的取值范围：

![1545795188736](系统级复习.assets/1545795188736.png)

### 2.2.2 无符号数编码

$$
对向量\vec x = [x_{w-1},x_{w-2},\cdots,x_0]:\\
二进制转无符号数：B2U(\vec x) = \sum^{w-1}_{i=0}x_i2^i\\
UMax_w=\sum^{w-1}_{i=0}2^i = 2^w-1, \quad 即[11\cdots 111]\\
UMin_w = 0, \quad 即[00\cdots 000]
$$



### 2.2.3 有符号数编码

- 补码编码(two's-complement)：最高位表示符号

  - 0表示非负数
  - 1表示负数

- $$
  对向量\vec x = [x_{w-1},x_{w-2},\cdots,x_0]:\\
  二进制转有符号数：B2T(\vec x) = -x_{w-1}2^{w-1}+\sum^{w-2}_{i=0}x_i2^i\\
  TMax_w=\sum^{w-2}_{i=0}2^i = 2^{w-1}-1, \quad 即[011\cdots11]\\
  TMin_w=-2^{w-1}, \quad 即[100\cdots00]
  $$

- 求反加一，或者可以如下理解：

![1545805078840](系统级复习.assets/1545805078840.png)



- 取值范围：
  - 无符号数：
    - UMin = 0 （00...00）
    - UMax = $2^w-1$（111....11）
  - 有符号数：
    - TMin = $-2^{w-1}$（100...0）
    - Tmax = $2^{w-1}-1$（011...1）
    - -1 (111...1) 与UMax二进制表示相同
  - 互相之间的关系
    - |TMin| = TMax+1
    - **UMax = 2*TMax+1**（TMax向左移动一位再+1）

### 2.2.4 有符号数和无符号数之间的转换

保持二进制表示，改变解释位的方式。即：

![](系统级复习.assets/02-1.png)

![1545805891029](系统级复习.assets/1545805891029.png)

- +/-$ 2^w$

### 2.2.5 C语言中的有符号数与无符号数

- 大多数数字默认为是有符号的，要创建无符号常量，必须加上后缀字符‘U’或‘u’（如：12345U）

- 显式类型转换：

  ```C++
  int tx,ty;
  unsigned ux,uy;
  
  tx = (int) ux;
  uy = (unsigned) ty;
  ```

- 隐式类型转换：

  ```C++
  int tx,ty;
  unsigned ux,uy;
  
  tx=ux;
  uy=ty;
  ```

- 当执行一个运算时，若一个表达式中既有无符号数又有符号数，则C语言会**隐式地将有符号参数强制类型转换为无符号数**，并假设这两个数都是非负的。

- $TMax_{32} = 2147483647, \quad TMin_{32}=-2147483647-1$

![1545807808903](系统级复习.assets/1545807808903.png)

求值的1、0表示该表达式的结果是对还是错，可见`-1<0U`是错的，`2147483647U>-2147483647-1`是错的。

```c
int min = -1;
unsigned int m = 1;
// min > m
```

#### 无符号数比有符号数更容易造成错误

```C++
unsigned i;
for(i= cnt-2;i>=0;i--)
    a[i]+=a[i+1];
//i是无符号数，当i=0时，再减一就会变成最大值，所以该循环是死循环
```

- `sizeof()`结果是无符号数

  `i-DELTA`是无符号数，永远大于0

  ```c
  #define DELTA sizeof(int)
  int i;
  for (i = CNT; i-DELTA >= 0; i-=DELTA)
  ...
  ```

#### 使用无符号数进行计数

（03-bits-ints-part2 P.28）

原理：一开始`i`小于`cnt`，进行循环，然后i减小到比0小时就会变成`i`数据类型的最大值，使得`i < cnt`不成立，结束循环。

注意：$UMax_w$是表示有w位的数据类型的最大值。

```C++
unsigned i; // unsigned就是unsigned int
for (i = cnt-2; i < cnt; i--)
	a[i] += a[i+1];
```

- 这里是可能出现问题的，依赖于机器是多少位的。unsigned 无论在32位还是64位机器下都是4字节，但是$UMax_{64}$是8字节的。当$cnt=UMax_{64}$时，就算i减小到比0小时就会变成`i`数据类型的最大值，也只是4字节的，依然比$UMax_{64}$小，这样就不能结束循环了，会导致死循环。

更好的表示：

```C++
size_t i;
for (i = cnt-2; i < cnt; i--)
	a[i] += a[i+1];
```

- `size_t`被定义为无符号数，且长度=字长，因此在32位机器下是4字节，64位机器下是8字节，这样i减小到比0小时就会变成`i`数据类型的最大值，会使得`i < cnt`不成立，结束循环，不会死循环。
- 即使cnt=UMax，也可以正常运行。

#### 需要使用无符号数的情况

1. 往一个字中放入描述各种布尔条件的标记(flag)时；
2. 把字仅仅看作是位的集合而没有任何数字意义时；
3. 表示地址时；
4. 实现模运算和多精度运算时；
5. 数字是由字的数组表示时。

### 2.2.6 扩展一个数字的位展示（Sign Extension）

- 一个常见的运算是在不同字长的整数之间转换，同时又保持数值不变。
- 将无符号数转换为一个更大的数据类型，只要简单地在表示的开头添加0，这称为**零扩展**。
- 将有符号数转换为一个更大的数据类型，可以执行一个**符号扩展**，即在表示中**添加最高有效位的值**。
  - 原理：填充的值之间互相抵消了，导致就算在左边加了好多个1也和最初的值是一样的。具体证明见教材P55推导部分。
- 注意：当数据转换既有位数扩充又有无符号数和有符号数的转换时，C语言标准要求是**先改变大小，再完成有符号和无符号数之间的转换。**
  - 如：short x-> unsigned 实际上是 (unsigned)(int)x，而不是(unsigned)(unsigned short) x。

![1545828380997](系统级复习.assets/1545828380997.png)

### 2.2.7 截断数字（Truncation）

- 减少表示一个数字的位数
- 规则：直接丢弃多余的最高位。
- 实际上是取模操作。
- 对于无符号数：取模操作： $B2U_k[x_{k-1},x_{k-2},\cdots,x_0]=B2U_w([x_{w-1},x_{w-2},\cdots,x_0])\,mod\,2^k$。
  - 如果数足够小，值不发生变化
  - 如果数太大，值会变化
- 对于有符号数：类似于取模操作：$B2T_k[x_{k-1},x_{k-2},\cdots,x_0]=U2T(B2U_w([x_{w-1},x_{w-2},\cdots,x_0])\,mod\,2^k)$，即将其转换为无符号数来取模，得到结果后再转换回有符号数。
  - 如果数足够小，符号和值不发生变化
  - 如果数太大，符号和值都发生变换

```c++
int x = 53191;
short sx = (short)x; // -12345
int y = sx; // -12345
```

- 当把x强制类型转换为short时，将32位int截断为16位short int；当把它强制类型转换回int，符号扩展把高16位设置为1，从而生成-12345的32位补码表示。

## 2.3 整数运算

### 2.3.1 无符号加法

$$
对满足0\le x,y< 2^w的x和y有：\\
x+y=
\left\{
\begin{aligned}
&x+y,x+y<2^w \qquad &&正常\\
&x+y-2^w,2^w\le x+y<2^{w+1}\qquad &&溢出
\end{aligned}
\right.
$$

![1545830075404](系统级复习.assets/1545830075404.png)

- 检测无符号数加法中的溢出：

  ![1545830203214](系统级复习.assets/1545830203214.png)

- **无符号数求反：**

  ![1545830269227](系统级复习.assets/1545830269227.png)

  因为$(x+2^w-x)mod \,2^w = 2^w mod\, 2^w =0$ ，详见教材P62。

### 2.3.2 有符号加法

![1545831737971](系统级复习.assets/1545831737971.png)

- 例子：

![1545831781192](系统级复习.assets/1545831781192.png)

- x+y超过TMax时，说发生了**正溢出**。

  x+y小于TMin时，说发生了**负溢出**。

- 检测有符号加法中的溢出：

  ![1545831963789](系统级复习.assets/1545831963789.png)



### 2.3.3 有符号数的非

![1545832910798](系统级复习.assets/1545832910798.png)

- **即对于TMin，加法的逆-x等于它本身**，因为就这个数是不对称的。
- 对于非Tmin的数，加法的逆为求反加一，即相反数。
- $\sim x$ 是x的反；-x 是x的加法的逆。
- $\sim x+1==-x$
- $\sim x + x = [111\cdots11]==-1$
- $-x+x==0$

### 2.3.4 无符号乘法

![1545832528943](系统级复习.assets/1545832528943.png)

- 其中，
  $$
  ^u_wy 表示无符号数y，仅取低w位
  $$

- 该式子表示，两个数相乘，若大于w位，则截断，仅取低w位



### 2.3.5 有符号乘法

![1545833321893](系统级复习.assets/1545833321893.png)

- 即计算乘积模$2^w$，再把无符号数转换为补码

![1545833451883](系统级复习.assets/1545833451883.png)



### 2.3.6 乘以常数

- 整数乘法需要的时钟周期要多余加减法、位级运算和移位
- 可以试着用移位和加法运算的组合来代替乘以常数因子的乘法

#### 乘以2的幂

- 无符号乘法：

$$
一个无符号数乘以2^k，等于该数字左移k位。（k\ge0）
$$

- 有符号乘法：
  $$
  一个有符号数乘以2^k，等于该数字左移k位。（k\ge0）
  $$









- 许多C语言编译器试图以移位、加法和减法的组合来消除很多整数乘以常数的情况
  $$
  x*14 =>(x<<3)+(x<<2)+(x<<1) \\
  14=2^3+2^2+2^1
  $$









### 2.3.7 除以2的幂

- 除以2的幂可以用右移来实现

- 无符号除法：

  ![1545834553894](系统级复习.assets/1545834553894.png)

  其中，$\lfloor x/2^k\rfloor$表示向下取整。

  x为int类型是，$x/2^k$会自动舍去小数，即向下取整。

  ![1545833451883](系统级复习.assets/02-3.png)

- 有符号除法：（向下舍入），不是我们想要的结果。

  ![1545834650238](系统级复习.assets/1545834650238.png)

  ![1545833451883](系统级复习.assets/02-4.png)

- 有符号除法：（向上舍入）结果与C语言中除法的处理一致。

  ![1545838139389](系统级复习.assets/1545838139389.png)书上这里写错了，应该是产生数值$\lceil x/2^k \rceil$。

  - 通过在执行算术右移之前加上一个适当的偏置量来使得结果能够正确舍入。低k位左边的位可能加1，也可能不加1.对于不需要舍入的情况，加上偏置量只影响那些被移掉的位。对于需要舍入的情况，加上偏置量导致较高的位加1，所以结果会向零舍入。

  ![1545833451883](系统级复习.assets/02-5.png)

  ![1545833451883](系统级复习.assets/02-6.png)




## 习题

![1545841141216](系统级复习.assets/1545841141216.png)

- 技巧：找特殊值检验：Tmax, Tmin, Umax, Umin, 0, -1。
- 重点关注第5、9、10、11、12题。
- 对于 x>>3 == x/8是错的：当x为-1时，x/8=0，x>>3并不等于0，(x+(1<<8)-1)>>8 == 0



# 3 程序的机器级表示

## 3.1 历史观点

略。需要知道几个名词：

1. x86：Intel处理器系列的俗称，指代整个系列。
2. IA32：Intel32位体系结构(Intel Architecture 32-bit)。
3. x86-64/Intel 64：IA32的64位扩展。
4. 指令集体系结构/架构 Architecture:(also ISA: instruction set architecture) The parts of a processor design that one needs to understand or write assembly / machine code.
   - e.g. instruction set specification, registers.
   - ISAs:
     - Intel: x86, IA32, Itanium, x86-64.  
     - ARM: Used in almost all mobile phones.
5. Microarchitecture: Implementation of the architecture.
   - e.g. cache sizes and core frequency.
6. Code Forms:
   1. Machine Code: The byte-level programs that a processor executes.
   2. Assembly Code: A text representation of machine code. 

## 3.2 程序编码

- gcc命令调用了一整套的程序，将源代码转化成可执行代码：
  - C**预处理器**扩展源代码，插入所有用#include指定的文件，并扩展所有用#define声明指定的宏
  - **编译器**产生源文件的汇编代码（.s）
  - **汇编器**将汇编代码转化为二进制目标代码文件（.o，机器代码的一种形式，包含所有指令的二进制表示，但没有填入全局值的地址）
  - **链接器**将两个目标代码文件与实现库函数（如printf）的代码合并，产生最终可执行代码文件
- -Og 编译参数告诉编译器使用会生成符号原始C代码整体结构的机器代码的优化等级。
- 使用较高级别优化产生的代码会严重变形，以至于产生的机器代码和初始源代码之间的关系非常难以理解。
- 较高级别的优化(如，-O1, -O2)会得到更好的程序性能。

![1545887757925](系统级复习.assets/1545887757925.png)



### 3.2.1 机器级代码

- 指令集体系结构或指令集架构（ISA）：定义机器级程序的格式和行为，它定义了处理器状态、指令的格式以及每条指令对状态的影响。
- ISA例子：
  - Intel：x86，IA32，Itanium，x86-64
  - ARM：用在几乎所有的手机上

### 3.2.2 代码示例

有C语言编写的文件sum.c：

- `gcc -Og -S sum.c`：产生汇编文件`sum.s`，不做其他工作
- `gcc -Og -c sum.c`：产生目标代码文件`sum.o`，二进制格式，无法直接查看
  - 反汇编器objdump：`objdump -d sum.o`
- `gcc -Og -o sum sum.c`：生成可执行文件`sum`
  - 反汇编：`objdump -d sum`

## 3.3 数据格式

Intel术语：

1. 字word：16位，2字节
2. 双字double words：32位，4字节
3. 四字quad words：64位，8字节。

![](系统级复习.assets/03-1.png)

## 3.4 访问信息

- 一个x86-64的CPU包含一组16个存储64位值的**通用目的寄存器**，用来存储整数数据和指针。
- 当复制和生成字节值的指令以寄存器作为目标时，对于生成小于8字节结果的指令，寄存器剩下的字节变化的规则有两条：
  1. 生成1字节和2字节数字的指令会保持剩下的字节不变；
  2. 生成4字节数字的指令会把高位4个字节置为0。

![1545890392393](系统级复习.assets/1545890392393.png)

![1545890537635](系统级复习.assets/1545890537635.png)

### 3.4.1 操作数指示符

- 大多数指令有一个或多个操作数，指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。
- 不同的操作数被分为三种类型：
  - **立即数**：表示常数值（$+C表示法表示的整数）
    - 例子：\$0x400, \$-533
    - 1、2或4字节
  - **寄存器**：表示某个寄存器的内容
    - 例子：%rax，%r13
  - **内存引用**：会根据计算出来的地址访问某个内存位置。
    - 例子：(%rax)
- 不同的寻址模式：

![1545892016762](系统级复习.assets/1545892016762.png)

- $Imm(r_b,r_i,s)$表示的是最常用形式。$Imm:立即数偏移；r_b:基址寄存器；r_i:变址寄存器；s：比例因子（必须是1、2、4或8）$
- 例子：

![1545892502328](系统级复习.assets/1545892502328.png)

### 3.4.2 数据传送指令

#### MOV类

![1545893376931](系统级复习.assets/1545893376931.png)

- mov后跟的第一个是源操作数，第二个是目的操作数
- 源操作数指定的值是一个立即数，存储在寄存器中或内存中
- 目的操作数指定一个位置，要么是一个寄存器，要么是一个内存地址
  - x86-64规定，**传送指令的两个操作数不能都指向内存位置**，将一个值从一个内存位置复制到另一个内存位置需要两条指令（加载到寄存器，写入目的位置）
- MOV指令中源和目的类型的五种可能的组合：

![1545893560053](系统级复习.assets/1545893560053.png)

## 3.5 算术和逻辑操作

### 3.5.1 加载有效地址(lea)

- 指令`leaq`加载有效地址，是`movq`的变形

  `leaq S,D`：$D\leftarrow \&S$

- 指令形式是从内存读数据到寄存器，但实际上它根本没引用内存，它的第一个操作数看上去是一个内存引用，但该指令并不是从指定的位置读入数据，而是将有效地址写入到目的操作数。

- 目的操作数必须是一个寄存器

- 使用：

  - 没有真正内存引用地计算地址
  - 计算算术表达式

- **leaq和movq的区别**：

  `leaq (%rax,%rbx) %rax`：是将%rax中的值加上%rbx中的值，放入%rax中。

  `movq (%rax,%rbx) %rax`：是将%rax中的值加上%rbx中的值，**所得值作为地址，访问内存中该地址，将地址中的值**放入%rax中。

![1545894312428](系统级复习.assets/1545894312428.png)

![1545894332978](系统级复习.assets/1545894332978.png)

**一些算术操作：**

![1545894401062](系统级复习.assets/1545894401062.png)

- 大多数指令不区分有符号和无符号数（仅右移区分）。
  - 原则上说，1个字节的移位量使得移位量的编码范围可以达到$2^8-1=255$。但实际上，在x86-64中，移位操作对w位长的数据值进行操作，移位量是由移位量的低m位决定的，这里$2^m=w$，高位会被忽略。
- imulq是有符号全乘法。

### 3.5.5 特殊的算术操作

略。讲有符号和无符号的64位乘法、128位除法。详见教材P133。

## 3.6 控制

### 3.6.1 条件码

- CPU还维护着一组单个位的**条件码寄存器**，它们描述了最近的算术或逻辑操作的属性
- 常用条件码：
  - CF：进位标志。最近的操作使最高位产生了进位，可用来检查无符号操作的溢出。
  - ZF：零符号。最近的操作得出的结果为0。
  - SF：符号标志。最近的操作得到的结果为负数。
  - OF：溢出标志。最近的操作导致一个补码溢出——正溢出或负溢出。
- 设置条件码：
  1. 隐式设置：
     - 算术操作的结果影响而设置的。
     - `leaq`指令不改变任何条件码，因为它是用来进行地址计算的。
  2. 显式设置：
     - 由CMP和TEST指令的结果设置。
     - CMP和TEST指令只设置条件码而不改变任何其他寄存器。

![1545895817243](系统级复习.assets/1545895817243.png)

### 3.6.2 访问条件码

- 条件码通常不会直接读取，常用的使用方法有三种：
  - 可以根据条件码的某种组合，将一个字节设置为0或1
  - 可以条件跳转到程序的某个其他的部分
  - 可以有条件地传送数据
- SET指令：读取条件码组合并设置一个字节为0或1：

![1545896396500](系统级复习.assets/1545896396500.png)

- `compq`指令的比较顺序：

  ![1545896755224](系统级复习.assets/1545896755224.png)

- `movzbl`不仅会把%eax的高3个字节清零，还会把整个寄存器%rax的高4个字节都清零。

### 3.6.3 跳转指令

![1545897005065](系统级复习.assets/1545897005065.png)

- jmp可以是直接跳转：跳转目标是作为指令的一部分编码的。写法：给出一个标号作为跳转目标。
- 也可以是间接跳转：跳转目标是从寄存器或内存位置中读出的。写法：‘*’后面跟一个操作数指示符。
  - `jmp *%rax` 用**寄存器%rax中的值**作为跳转目标。
  - `jmp *(%rax)`以%rax中的值作为读地址，**从内存中读出跳转目标**。

### 3.6.5 用条件控制来实现条件分支

- C允许使用`goto`语句，形式与汇编代码的控制流非常类似。

  - 通过标签来无条件跳转
  - `gcc –Og -S –fno-if-conversion control.c`

- 代码形式：

  - C代码：

    ```C
    val = Test ? Then_Expr : Else_Expr;
    ```

  - Goto代码：（汇编代码形式与此类似）

    ```c
    	ntest = !Test;
    	if(ntest) goto Else;
    	val = Then_Expr;
    Else:
    	val = Else_Expr;
    Done:
    ....
    ```

- 即汇编器会为then, else表达式**产生各自单独的代码块**，执行的时候选择合适的一个。

### 3.6.6 用条件传送来实现条件分支

- 使用**数据**的条件转移：计算一个条件操作的两种结果，然后再根据条件是否满足来从中选取一个。只有在一些受限制的情况中，这种策略才可行。若该策略可行，就可以用一条简单的条件传送指令来实现它。

- 基于条件数据传送的代码会比基于条件控制转移的代码性能要好
  - 分支容易对于流水线机制产生扰乱
  - 条件传送并不要求控制转移，处理器无需预测测试的结果就可以执行条件传送。处理器只是读源值（可能是从内存中），检查条件码，然后要么更新目的寄存器，要么保持不变。

- 代码形式：

  - C代码：

    ```C
    val = Test ? Then_Expr : Else_Expr;
    ```

  - Goto代码：（汇编代码形式与此类似）

    ```c
    result = Then_Expr;
    eval = Else_Expr;
    ntest = !Test;
    if(ntest) result = eval;
    return result;
    ```

![1545897697661](系统级复习.assets/1545897697661.png)



- 条件传送指令：

![1545897730503](系统级复习.assets/1545897730503.png)

#### 条件传送存在的问题

- 由于无论测试结果如何，代码都会对then，else对应的表达式求值，因此如果这两个表达式中的任意一个可能产生错误条件或者副作用，就会导致非法的行为。
  - 错误条件：`val = p ? *p : 0;`   在计算`*p`时，如果是空指针，就会导致一个间接引用空指针的错误，因此必须用分支代码来编译这段的代码。
  - 副作用：`val = x > 0 ? x*=7 : x+=3;`   x的值被计算了两次，可能不是预期的效果。

- 当每一个分支需要大量的计算时，条件传送就无法提高代码的效率。



### 3.6.7 循环

#### do-while循环

至少执行一次body-statement。

通用形式：

- C代码：

  ```
  do
  	body-statement
  	while(test-expr);
  ```

- Goto代码：

  ```
  loop:
  	body-statement
  	t = test-expr;
  	if(t)
  		goto loop;
  ```


![1545899627944](系统级复习.assets/1545899627944.png)

![1545899652877](系统级复习.assets/1545899652877.png)

#### while循环

##### 第一种翻译方法（jump to middle）

- 先执行一个无条件跳转跳到循环结尾处测试，以此来执行初始的测试。

- GCC优化命令行选项为`-Og`。

![1545899709617](系统级复习.assets/1545899709617.png)

![1545899762942](系统级复习.assets/1545899762942.png)

##### 第二种翻译方法

- 首先用条件分支，如果初始条件不成立就跳过循环，把代码变换为do-while循环。

- GCC优化命令行选项为`-O1`。

![1545899827937](系统级复习.assets/1545899827937.png)

![1545899841641](系统级复习.assets/1545899841641.png)

#### for循环

##### for循环→while循环

C语言标准说明，for循环的与while循环可以完全转换；但是要注意，**当循环内出现continue语句时，将for循环翻译成while循环的描述规则需要一些改进**。

![1545899947538](系统级复习.assets/1545899947538.png)

- 通用形式：

  - jump to middle

    ```
    	init-expr;
    	goto test;
    loop:
    	body-statement
    	update-expr;
    test:
    	t = test-expr;
    	if(t)
    		goto loop;
    ```

  - guarded-do

    ```
    	init-expr;
    	t = test-expr;
    	if(!t)
    		goto done;
    loop:
    	body-statement
    	update-expr;
    	t = test-expr;
    	if(t)
    		goto loop;
    done:
    ```


![1545899963101](系统级复习.assets/1545899963101.png)

##### for循环→do-while循环

![1545900000609](系统级复习.assets/1545900000609.png)



### 3.6.8 switch语句

- 使用**跳转表**的数据结构使得实现更加高效。
  - 跳转表是一个数组，表项i是一个代码段的地址，该代码段实现当开关索引值等于i时程序应采取的动作。跳转表在汇编代码中，实际上是放在目标代码文件的`.rodata`（只读数据，Read-Only Data）段中。标号.L4标记出这个分配空间的起始地址，与这个标号相对应的地址会作为间接跳转的**基地址**。在这个分配空间内，有一组7个“四”字（8个字节），每个字的值都是与指定的汇编代码标号相关联的指令地址，即不同case执行的代码块的起始地址。
  - 与多个if-else语句相比的优点：执行开关语句的时间与开关情况的数量无关。
  - 适合索引值数量比较多，并且值的范围跨度比较小的时候。当索引值稀疏时，可能会使用决策树(if-elseif-elseif-else)。

  ![](系统级复习.assets/03-2.png)

![1545900843392](系统级复习.assets/1545900843392.png)

![1545900224695](系统级复习.assets/1545900224695.png)

![1545900863299](系统级复习.assets/1545900863299.png)

- 几种特殊情况的switch：

  - 无break：对应代码块结尾没有`jmp`到结尾，而是会接着往下执行。

  ![1545901115306](系统级复习.assets/1545901115306.png)

  - 某个case无内容：与下一个case（即实际执行的case）共用一个代码块。

    ![1545901156893](系统级复习.assets/1545901156893.png)

## 3.7 过程

- 过程的机制：（假设过程P调用过程Q）
  - 传递控制：在进入过程Q的时候，程序计数器必须被设置为Q的代码的起始地址，然后在返回时，要把程序计数器设置为过程P中调用Q后面那条指令的地址。
  - 传递数据：P必须能够向Q提供一个或多个参数，Q必须能够向P返回一个值。
  - 分配和释放内存：在开始时，Q可能需要为局部变量分配空间，而在返回前，必须释放这些存储空间。

### 3.7.1 运行时栈

- 使用栈数据结构来进行内存管理

- 栈和程序寄存器存放着传递控制和数据、分配内存所需要的信息

  - 当P调用Q时，控制和数据信息添加到栈尾；当P返回时，这些信息会释放掉

  ![1545918860693](系统级复习.assets/1545918860693.png)

- x86-64的栈向低地址方向增长，而栈指针%rsp指向栈顶元素。

- 当x86-64过程需要的存储空间超过寄存器能存放的大小时，就会在栈上分配空间，这个部分称为过程的**栈帧**

- 当过程P调用过程Q时，会把返回地址压入栈，指明当Q返回时，要从P程序的哪个位置继续执行。我们把这个返回地址当作P的栈帧的一部分，因为它存放的是与P相关的状态。

- 通过寄存器，过程P可以传递最多6个整数值（也就是指针和整数），但是如果Q需要更多的参数，P可以在调用Q之前在自己的栈帧里存储好这些参数。

- x86-64过程只分配自己所需要的栈帧部分。例如，许多过程有6个或者更少的参数，那么所有的参数都可以通过寄存器传递。实际上，很多函数甚至不需要栈帧。

- `pushq Src`：

  - 从Src中取出操作数
  - 将%rsp减8（栈大小）
  - 在%rsp地址处写入操作数

- `popq Dest`：

  - 读出%rsp指向地址的值
  - %rsp加8
  - 将值存在Dest处（必须是一个寄存器）

### 3.7.2 转移控制

- `call`和`ret`指令：

![1545919293126](系统级复习.assets/1545919293126.png)

- `call`会把地址A（为返回地址，是紧跟在call指令后的那条指令的地址）压入栈中，并将PC设置为Q的起始地址。
- `ret`指令会从栈中弹出地址A，并把PC设置为A
- （具体例子：chapter3_3 P.10~13）

### 3.7.3 数据传送

- x86-64中，可以通过寄存器最多传递6个整型参数。
- 寄存器的使用有特殊顺序，寄存器使用的名字取决于要传递的数据类型的大小。
- 会根据参数在参数列表中的顺序为它们分配寄存器

![1545996049643](系统级复习.assets/1545996049643.png)

- 如果有超过6个参数的部分就要通过栈来传递。
- 假设过程P调用过程Q，有n个整型参数，且n>6，那么要把参数1-6复制到对应的寄存器，把参数7-n放到栈上，而**参数7位于栈顶**。
- 通过栈传递参数时，**所有的数据大小都向8的倍数对齐。**
- 参数到位以后，程序就可以执行call指令将控制转移到过程Q了。过程Q可以通过寄存器访问参数，必要的时候也可以通过栈访问。

#### 例子

![](系统级复习.assets/03-3.png)

![](系统级复习.assets/03-4.png)

- 从例子可以看出，栈帧数据大小都向8的倍数对齐。
- 这个例子有多种不同类型的参数。注意汇编指令第6行的movl指令从内存读入4字节，而后面的addb指令只使用其中的低位一字节。

### 3.7.4 栈上的局部存储

（函数调用的栈变化chapter3_3 P.21~31）

- x86-64/Linux 栈：

![1545998575846](系统级复习.assets/1545998575846.png)

- 有的时候，局部数据必须存放在内存中，常见的情况包括：
  - 寄存器不足够存放所有的本地数据
  - 对一个局部变量使用地址运算符’&‘，因此必须能够为它产生一个地址
  - 某些局部变量是数组或结构，因此必须能够通过数据或结构引用被访问到

例子：

- chapter3_3 P.33~38

- 教材P171-172

  - 关注不同类型参数在栈中的排布：

  ![](系统级复习.assets/03-5.png)

### 3.7.5 寄存器中的局部存储空间

寄存器组是唯一被所有过程共享的资源。必须确保当一个过程调用另一个过程时，被调用者不会覆盖调用者稍后会使用的寄存器值。x86-64采用了一组统一的寄存器使用惯例，所有的过程都必须遵循。

- %rbx、%rbp和%r12~%r15被划分为**被调用者保存**寄存器
  - 过程P调用过程Q，Q必须保存这些寄存器的值，保证当Q返回到P时，它们的值和Q被调用时是一样的。
  - 不改变它们，或者压入栈中，返回前弹出。
- 所有的其他寄存器，除%rsp外的指针，都分类为**调用者保存**寄存器
  - 即任何函数都能修改它们
  - 理解”调用者保存“：调用者有责任去保存值的寄存器，因为其他的过程有可能会修改它。因此在调用其他过程前，当前过程必须保存寄存器的值。
- 例子（chapter3_3 P43~44）

### 3.7.6 递归过程

chapter3_3 P.46~52

## 3.8 数组分配和访问

### 3.8.1 基本原则

对于数据类型T和整型常数N，声明如下：
$$
T\ A[N]
$$

- 起始位置表示为$x_A$。
- 内存中分配一个L*N字节的连续区域（L是数据类型T(`sizeof(T)`)的大小，单位为字节）
- 其次，它引入了标识符A，可以用A来作为指向数组开头的指针，这个指针的值就是$x_A$。
- 可以用0～N-1的整数索引来访问该数组元素。数组元素i会被存放在地址为$x_A+L·i$ 的地方。

![1546014294870](系统级复习.assets/1546014294870.png)



### 3.8.2 指针运算

- C语言允许对指针进行运算，而计算出来的值会根据该指针引用的数据类型的大小进行伸缩。也就是说，如果p是一个指向类型为T的数据的指针，p的值为$x_p$，那么表达式 $p+i$ 的值为 $x_p+L·i$，这里L是数据类型T的大小。



![1546014349192](系统级复习.assets/1546014349192.png)

- 数组例子：

![1546014594882](系统级复习.assets/1546014594882.png)

![1546014627967](系统级复习.assets/1546014627967.png)

- %rdi存放作为第一个参数的数组的首地址，%rsi存放数组索引



### 3.8.3 嵌套数组

Nested Array 嵌套数组：每行元素个数相同，每行紧密排列，可以展开成一个一维数组。

![](系统级复习.assets/03-6.png)

- 创建数组的数组：

  ```C++
  int A[5][3];
  // 等价于
  typedef int row3_t[3];
  row3_t A[5];
  ```

  - 5行3列的二维数组

声明一个数组：
$$
T \quad D[R][C]
$$
它的数组元素D\[i][j]的内存地址为
$$
\&D[i][j] = x_D + L(C·i+j)
$$
这里，L是数据类型T的大小。

#### 多层次数组（Multi-level Array）

数组中每个元素是一个指针，每个元素指针指向对应的数组；因此不同行元素的地址可能不是紧挨着，同时每行元素个数可以不一样。数组中的元素指针的值（地址）不连续。

- 想要得到数组元素，必须进行**两次内存访问**：

  1. 得到行数组的指针
  2. 再利用指针去访问行数组

  ```
  现有数组：T univ[index][digit]
  size = sizeof(T)
  访问数组元素：Mem[Mem[univ+8*index]+size*digit]
  ```

![](系统级复习.assets/03-7.png)



### 3.8.4 定长数组

C语言编译器能优化定长多维数组上的操作代码。

例如，生成16X16的整型数组。需要计算矩阵A和B的乘积的元素i，k，即A的行i和B的列k的内积。

- 可以把所有的数组引用都转换为指针间接引用
- 生成指向A的行i中连续的元素的指针。
- 生成指向B的列k中连续的元素的指针。



## 3.9 异质的数据结构

### 3.9.1 结构

![1546062149418](系统级复习.assets/1546062149418.png)

- 结构的所有组成部分都存放在内存中一段连续的区域内
- 每个部分在内存中存储的顺序根据其声明顺序来定
- 要产生一个指向结构内部对象的指针，只需将结构的地址加上该字段的偏移量。

![1546063079644](系统级复习.assets/1546063079644.png)

- 注意，`->`优先级高于`&`，即`&r->a[idx]` 等价于 `&(r->a[idx])`。
- 注意，`.`优先级高于`*`, 即`*rp.width` 等价于 `*(rp.width)`，因此如果要访问rp指向结构的width字段，必须加括号 `*(rp).width`，也就等价于 `rp->width`。

### 3.9.2 联合

（chapter3_5 P.39）可以绕过C语言的类型系统。

- 用不同的字段来引用相同的内存块

  - 如，用联合来表示二叉树的节点，既可表示叶子节点又可表示内部节点。

- 一个联合的总的大小等于它最大字段的大小

- 一次只能使用一个字段

- 联合还可以用来访问不同数据类型的位模式：

  ![1546087069085](系统级复习.assets/1546087069085.png)

  - 在小端的机器上，此时temp.u[0]是d的低位4个字节，temp.u[1]是d的高位4个字节

- 在不同的机器上运行，当类型字节数更改后，可能会出现问题

![1546087475348](系统级复习.assets/1546087475348.png)



### 3.9.3 数据对齐

- Intel建议要对齐数据以提高内存系统的性能

- **对齐原则：任何K字节的基本对象的地址必须是K的倍数**

- 结构的对齐：

  - 对于包含结构的代码，编译器可能需要在字段的分配中插入间隙
  - **每个结构对齐要求的K=所需字节数最大的组成成分的字节数**
  - 结构的长度必须是K的倍数
  - 结构里有结构元素：以里面结构元素的最大字节来对齐。

  ![1546067155945](系统级复习.assets/1546067155945.png)

![1546067169347](系统级复习.assets/1546067169347.png)

- 结构体节省空间：

  - 将大的数据类型放在前面

  ![1546067390393](系统级复习.assets/1546067390393.png)

  ![1546067401976](系统级复习.assets/1546067401976.png)

## 3.11 浮点代码

（chapter3_4 P.33）

- AVX浮点体系结构允许数据存储在16个YMM寄存器中
- 每个XMM寄存器都是对应的YMM寄存器的低128位

![1546068042817](系统级复习.assets/1546068042817.png)



### 3.11.2 过程中的浮点代码

- XMM寄存器用来向函数传递浮点参数，以及从函数返回浮点值

- 规则：

  - 最多传递8个浮点参数%xmm0~%xmm7

  - %xmm0用来返回浮点值

  - 所有的XMM寄存器都是调用者保存的

  - 当参数包含指针、整数和浮点数混合时，指针和整数通过通用寄存器传递，浮点值通过XMM寄存器传递

    ![1546069420513](系统级复习.assets/1546069420513.png)

- 在XMM寄存器之间或XMM和内存之间传递：

  ![1546069557789](系统级复习.assets/1546069557789.png)

- 其他：

  - 浮点比较：
    - `ucomiss`和`ucomisd`
    - 设置条件码CF，ZF和PF
  - 使用常量值
    - 设置%xmm0为0：`xorpd %xmm0, %xmm0`

## 理解指针和数组

（chapter3_4 P.40~46）



## 3.10 在机器级程序中将控制与数据结合起来

（chapter3_5）

- Linux内存层次：

![1546070293355](系统级复习.assets/03-8.png)

### 3.10.1 理解指针

略。教材P192

- 数组与指针紧密联系。一个数组的名字可以像一个指针变量一样引用（**但是不能修改**）。数组引用（例如`a[3]`）与指针运算和间接引用（例如`*(a+3)`）有一样的效果。**数组引用和指针运算都需要用对象大小对偏移量进行伸缩。**
- 将指针从一种类型强制转换为另一种类型，只改变它的类型，而不改变它的值。**强制类型转换的一个效果是改变指针运算的伸缩。**例如，如果P是一个`char*`类型的指针，它的值为p，那么表达式`(int*)P+7`计算为p+28，而`(int*)(P+7)`计算为p+7。（强制类型转换的优先级高于加法。）
- 指针也可以指向函数。函数指针的值是该函数机器代码表示中第一条指令的地址。



### 3.10.3 内存越界引用和缓冲区溢出

- 对越界的数组元素的写操作会破坏存储在栈中的状态信息。

![1546071394559](系统级复习.assets/1546071394559.png)

![1546071508320](系统级复习.assets/1546071508320.png)



- 以上的问题称为**缓冲区溢出**（访问超过数组大小的地址时）
- 常出现在：
  - 未检查输入字符串长度
  - 特别是对于栈上的有界字符数组
- 例子：

![1546076918751](系统级复习.assets/1546076918751.png)

​	该函数没有办法确定是否为保存整个字符串分配了足够的空间。

![1546077098264](系统级复习.assets/1546077098264.png)

![1546077108267](系统级复习.assets/1546077108267.png)

​	栈中的信息：

![1546077127573](系统级复习.assets/1546077127573.png)

若返回地址的值被破坏了，那么ret指令会导致程序跳转到一个完全想象不到的位置。

#### 代码注入攻击

- 缓冲区溢出的一个更加致命的使用是让程序执行它本来不愿意执行的函数，这是最常见的一种通过计算机网络攻击系统安全的方法。

  - 向一个程序注入一个字符串，注入的字符串中包括可执行代码的字节编码，成为攻击代码（exploit code）。
  - 另一些字节会用一个指向攻击代码的指针覆盖返回地址，那么，ret指令的效果就是跳转到攻击代码。

- 蠕虫：可以自己运行，并且能够将自己的等效副本传播到其他机器。

  病毒：能将自己添加到包括操作系统在内的其他程序中，但它不能独立运行。

### 3.10.4 对抗缓冲区溢出攻击

1. 在代码中防止出现缓冲区溢出的现象（防止数组越界）
2. 系统级保护措施如下：

#### 1. 栈随机化

栈的位置在程序每次运行时都有变化，所以即使许多机器运行同样的代码，它们的栈地址也是不同的。

这可使得攻击者无法确定攻击代码的首地址，从而无法将指向攻击代码的指针写入ret。

#### 2. 栈破坏检测

检测何时栈已经被破坏。
     - GCC栈保护者机制：在栈帧中任何局部缓冲区与栈状态之间存储一个特殊的**金丝雀值**（哨兵值），在程序每次运行时随机产生。因此，攻击者没简单的办法知道它是什么。在恢复寄存器状态和从函数返回之前，程序检查金丝雀值是否被改变，若是，则程序异常终止。
     -  用`-fno-stack-protector`命令行选项可以阻止GCC产生这种代码。
     - ![1546079644457](images/1546079644457.png)

#### 3. 限制可执行代码区域

限制哪些内存区域能够存放可执行代码。

在典型的程序中，只有保存编译器产生的代码的那部分内存才需要是可执行的。其他部分可以被限制为只允许读和写。

  - 在传统的x86系统下，可以标记内存区域为“只读”或“可写”。
  - x86-64添加了"可执行"权限。



（chapter3_5 P.34~37 Return-Oriented Programming Attacks和ROP Execution略）

> - 对于所有运行同样程序和操作系统版本的系统来说，在不同的机器之间，栈的位置是相对固定的。因此，如果攻击者可以确定一个常见的Web服务器所使用的栈空间，就可以设计一个在许多机器上都能实施的攻击。以传染病来打个比方，许多系统都容易受到同一种病毒的攻击，这种现象常被称作**安全单一化。**
> - 在Linux系统中，栈随机化已经变成标准行为。它是更大的一类技术中的一种，这类技术称为地址空间布局随机化（Address-Space Layout Randomization），简称ASLR。
>
> 其他内容，详见教材P198-199



# 5 优化程序性能

## 5.1 优化编译器的能力和局限性

- 优化编译器的局限性：

  - 只使用安全的优化，即对于程序可能遇到的所有可能情况，优化后得到的程序和未优化的版本有一样的行为。

    - **内存别名使用(memory aliasing)**：两个指针可能指向同一个内存位置。

    ![1546088972484](系统级复习.assets/1546088972484.png)

    `twiddle2`比`twiddle1`效率更高，因为它访问内存的次数要少些，但是当xp==yp时，两个的运行结果会不一样，所以编译器不会将`twiddle1`的代码优化为`twiddle2`。

    - **函数调用的副作用**：

      ![1546089254118](系统级复习.assets/1546089254118.png)

      `func1()`看起来很可能会优化为`func2()`（2只调用f一次，而1要调用4次）。但是：

      ![1546089312752](系统级复习.assets/1546089312752.png)

      此时，`func1()`和`func2()`结果不一样。

      这个函数有个副作用——它修改了全局程序状态的一部分，改变调用它的次数会改变程序的行为。

      大多数编译器不会试图判断一个函数是否没有副作用，相反它会假设最糟糕的情况（编译器把函数当作黑盒处理），并保持所有的函数调用不变。

> **内联函数替换：**
>
> 包含函数调用的代码可以用一个称为**内联函数替换**的过程进行优化，此时，将函数调用替换为函数体。这样的转换既减少了函数调用的开销，又允许对展开的代码做进一步优化。
>
> GCC新版本可以用命令行选项“-finline”，也可以使用优化等级-O1或者更高等级的优化来实现内联。但是它只尝试在单个文件中定义的函数的内联；无法做到在一个文件定义的函数，在其他文件被调用的内联。
>
> 在一些情况下最好阻止编译器执行内联替换。
>
> 1. 用符号调试器来评估代码，如GDB。如果一个函数内联替换优化了，任何对这个调用进行追踪或设置断点的尝试都会失败。
> 2. 用代码剖析的方式来评估程序性能，此时用内联替换消除的函数调用是无法被正确剖析的。

## 5.2 表示程序性能

- 度量标准：**每元素的周期数（CPE）**

略。教材P345-347

## 常用的有效的优化方法

### 5.4 代码移动

消除循环的低效率。

- 识别需要执行多次但计算结果不会改变的计算，从而可以将计算移动到代码前面不会被多次求值的部分。
  - 如，从循环内部移动到循环的前面。

![1546089694114](系统级复习.assets/1546089694114.png)

- 例子：

![1546090458062](系统级复习.assets/1546090458062.png)

- 将`strlen(s)`函数调用放到循环外面，提高了运行效率。
- 但编译器不会进行这样的优化，因为担心函数会产生副作用，所以需要程序员自己进行优化。

### 运算强度降低

- 将一些开销大的计算替代为开销小的计算
  - 使用移位和加法来替代乘法和除法

![1546089979069](系统级复习.assets/1546089979069.png)

### 分享共同的子表达式

- 重用部分表达式
- GCC的`-O1`将会进行这样的优化

![1546090061259](系统级复习.assets/1546090061259.png)



### 5.6 消除不必要的内存引用

![1546091069016](系统级复习.assets/1546091069016.png)

- 每次迭代都会更新`b[i]`，即每次迭代都要对内存进行读写
- 可以通过添加临时变量来消除这样的内存引用

![1546091142907](系统级复习.assets/1546091142907.png)



## 5.7 理解现代处理器

![1546092015616](系统级复习.assets/1546092015616.png)

- 
- 有两个主要部分：**指令控制单元（ICU）**和**执行单元（EU）**
  - 指令控制单元：负责从内存中读出指令序列，并根据这些指令序列生成一组针对程序数据的基本操作
  - 执行单元：执行操作
- **超标量处理器（superscaler）**
  - 目的：可以在每个时钟周期执行多个操作，且指令执行的顺序不一定与它们在机器级程序中的顺序一致（乱序的）
  - 优点：能更好地达到更高的指令级并行度
  - 大多数现代CPU都是超标量的

（chapter5 P.30~33 不知怎么整理）



## 5.8 循环展开

- 是一种程序变换，通过增加每次迭代计算的元素的数量，减少循环的迭代次数。
- 从两个方面改进程序的性能：
  - 减少了不直接有助于程序结果的操作的数量（如：循环索引计算和条件分支）
  - 提供了一些方法，可以进一步变化代码，减少整个计算中关键路径上的操作数量

![1546093217980](系统级复习.assets/1546093217980.png)

- “k*1循环展开”：每次迭代处理数组的k个元素。
  - 上限应设为$n-k+1$
  - 在循环内对元素$i$到$i+k-1$应用合并运算
  - 每次迭代，循环索引 i 加 k
  - 第二个循环，每次处理一个元素，处理向量的最后几个元素