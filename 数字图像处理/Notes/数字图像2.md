# 8 图像压缩（重点）

## 概述

### 编码的定义

![编码定义](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E7%BC%96%E7%A0%81%E5%AE%9A%E4%B9%89.png)

- 无损压缩常用方法：统计编码。利用消息或消息序列出现概率的分布特性，注重寻找概率与码字长度间的最优匹配。

## 预测编码

### 基本原理

 预测编码（Predictive Coding)，就是根据“过去”的时刻的像素值，运用一种模型，预测当前的像素值，预测编码通常不直接对信号编码，而是对预测误差进行编码。当预测比较准确，误差较小时，即可达到编码压缩的目的。

- 原理：对图象的一个像素的离散幅度的真实值，利用其相邻象素的相关性，预测它的下一个象素的可能值，再求两者差，对这种具有预测性质的差值，量化，编码，就可以达到压缩的目的。

- 基本思想：

  ![预测编码基本思想](../../../../../%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E9%A2%84%E6%B5%8B%E7%BC%96%E7%A0%81%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3.png)

- 基本流程：

  ![预测编码基本流程](../../../../../%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E9%A2%84%E6%B5%8B%E7%BC%96%E7%A0%81%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B.png)

- 概念解释：

  ![预测编码1](../../../../../%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E9%A2%84%E6%B5%8B%E7%BC%96%E7%A0%811.png)

- 示例：

  ![预测编码2](../../../../../%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E9%A2%84%E6%B5%8B%E7%BC%96%E7%A0%812.png)

- 收发误差：

  ![预测编码3](../../../../../%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E9%A2%84%E6%B5%8B%E7%BC%96%E7%A0%813.png)

- 注意：

  1. 见上面多点预测。
  2. 每行的最开始的几个像素无法预测，这些像素需要用其他方式编码，这是采用预测编码所需要的额外操作。
  3. 预测系数随着不同的图象而不同，但对每幅图象都计算预测系数太麻烦，也不现实，可参考前人得到的数据选择使用。在静止图象压缩的国际标准(JPEG)中，对这种方法的前置点形式以及预测系数有一推荐值可供参考。

### 分类

1. 预测编码：在均方误差最小的准则下，使其误差最小的方法。   
2. 线性预测：利用线性方程计算预测值的编码方法。线性预测编码方法，也称差值脉冲编码调（Differential Pulse Code Modulation，DPCM）
3. 非线性预测：利用非线性方程计算预测值的编码方法。。   
4. 帧内预测编码：根据同一帧样本进行预测的编码方法。
5. 帧间预测编码：根据不同帧样本进行预测的编码方法。   
6. 自适应预测编码（ADPCM）：预测器和量化器参数按图像局部特性进行调整的编码方法。
7. 条件补充帧间预测编码：在帧间预测编码中，若帧间对应像素样本值超过某一阈值就保留，否则不传或不存，恢复时就用上一帧对应像素样本值来代替，称为条件补充帧间预测编码。   
8. 运动补偿预测编码：在活动图像预测编码中，根据画面运动情况，对图像加以补偿再进行帧间预测的方法称为运动补偿预测编码方法。



预测编码法是一种设备简单、质量较佳的高效编码法。预测编码方法主要有二种：

1. 差分脉冲编码调制编码(Differential Pulse Code Modulation)或 DPCM 编码法。
2. 增量调制编码(Delta modulation)或 △Ｍ（DM）编码 

### 无损预测编码

#### 编码思想

认为相邻像素的信息有冗余。当前像素值可以用以前的像素值来获得。（去除像素冗余）

#### 操作

- 用当前像素值$f_n$，通过预测器得到一个预测值$\hat f_n$，对当前值和预测值求差，**对差编码**，作为压缩数据流中的下一个元素。
- 由于差比原数据要小，因而编码要小，可用变长编码。大多数情况下， $f_n$的预测是通过m个以前像素的线性组合来生成的。

![无损编码](../../../../../%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E6%97%A0%E6%8D%9F%E7%BC%96%E7%A0%81.png)

#### 编码与解码过程

编码过程：

1. 第一步：压缩头处理
2. 第二步：对每一个符号：f(x,y)，由前面的值， 通过预测器， 求出预测值$\hat f(x,y)$
3. 第三步：求出预测误差 ：$e(x,y) = f(x,y) - \hat f(x,y)$
4. 第四步：对误差e(x,y)编码，作为压缩值。
5. 重复二、三、四步



解码过程：

1. 第一步：对头解压缩
2. 第二步：对每一个预测误差的编码解码，得到预测误差 e(x,y)。
3. 第三步：由前面的值，得到预测值$\hat f(x,y)$。
4. 第四步：误差e(x,y)，与预测值$\hat f(x,y)$相加， 得到解码f(x,y)。
5. 重复二、三、四步



![无损编码2](../../../../../%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E6%97%A0%E6%8D%9F%E7%BC%96%E7%A0%812.png)

### 有损预测编码

#### 介绍

- 有损压缩是：
  - 通过牺牲图像的准确率来达到加大压缩率的目的
  - 如果我们容忍解压缩后的结果中有一定的误差，那么压缩率可以显著提高
- 有损压缩方法的压缩比：
  - 在图像压缩比大于30:1时，仍然能够重构图像
  - 在图像压缩比为10:1到20:1时，重构图像与原图几乎没有差别
  - 无损压缩的压缩比很少有能超过3:1的
- 无损压缩和有损压缩的区别：这两种压缩方法的**根本差别在于有没有量化模块**。

#### 量化器

- 基本思想：
  - 减少数据量的最简单的办法是将图像量化成较少的灰度级，通过减少图像的灰度级来实现图像的压缩
  - 这种量化是不可逆的，因而解码时图像有损失。
- 例如：如果输入是256 个灰度级，对灰度级量化后输出，只剩下4个层次，数据量被大大减少。

#### 编码思想

对无损预测压缩的误差进行量化，通过消除视觉心理冗余，达到对图像进一步压缩的目的。

算法的演变：

1. 无损预测压缩的基础是：
   - 原图像值$f_n$与预测值$\hat f_n$之间的误差$e_n$。有公式：$e_n = f_n – \hat f_n$
   - 解码与编码使用相同的预测器。
2. 有损预测编码的演变——引入量化：**将$e_n$量化**：$\hat e_n = Q(e_n)$，用$\prime f_n = \hat e_n + \hat f_n$近似$f_n: f_n \approx  \prime f_n$。
   - 编码：$\hat e_n = Q(f_n-\hat f_n)$
   - 解码：$\prime f_n = \hat e_n + \hat f_n$

![有损编码1](../../../../../%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E6%9C%89%E6%8D%9F%E7%BC%96%E7%A0%811.png)

![有损编码2](../../../../../%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E6%9C%89%E6%8D%9F%E7%BC%96%E7%A0%812.png)

### $\Delta$M编码

#### 编码译码过程

 △M编码器包括**比较器、本地译码器和脉冲形成器**三个部分。收端译码器比较简单，它只有一个与编码器中的本地译码一样的译码器及一个视频带宽的低通滤波器。

![DM编码](../../../../../%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/DM%E7%BC%96%E7%A0%81.png)

- 在发端：

  - 当差值e(t)为一个正的增量时用“1”码来表示，
  - 当差值e(t)为一个负的增量时用“0”码来表示。

- 在收端：

  - 当译码器收到“1”时，信号则产生一个正跳变，
  - 当译码器收到“0”时，则信号电压产生一个负的跳变，

  由此即可实现译码。

#### 量化器与预测器

![DM编码量化预测](../../../../../%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/DM%E7%BC%96%E7%A0%81%E9%87%8F%E5%8C%96%E9%A2%84%E6%B5%8B.png)

![DM编码量化](../../../../../%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/DM%E7%BC%96%E7%A0%81%E9%87%8F%E5%8C%96.png)

#### 例子

![DM编码例子](../../../../../%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/DM%E7%BC%96%E7%A0%81%E4%BE%8B%E5%AD%90.png)

#### 算法分析

![DM编码例子2](../../../../../%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/DM%E7%BC%96%E7%A0%81%E4%BE%8B%E5%AD%902.png)



![DM编码算法分析](../../../../../%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/DM%E7%BC%96%E7%A0%81%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90.png)

#### 基本特性

1. 斜率过载特性：

   由△M的编码原理可知，$\hat f(t)$应很好地跟踪f(t)，跟踪得越好，误差e(t)越小。当△M编码器出现连“1”或连“0”码时，就说明输入模拟信号f(t)有较大的斜率。

2. △M的量化噪声：
   △M编码法量化噪声在不过载的情况下，量化噪声的幅度不会超过±△，而且，可认为在－△～＋△范围内量化噪声是以等概率出现的。在译码时，由于有一个截频为 $f_m$ 的低通滤波器，它将抑制一部分量化噪声。 式中 $f_s$ 是取样频率。因此，量化噪声表示为$\bar N_q = \frac{\Delta^2}{3}\frac{f_m}{f_s}$。

3. △M的量化信噪比：
   一般量化噪声的大小并不能完全说明一幅图像质量的好坏。与语音信号编码一样，信号幅度（或功率）与噪声幅度(或功率)的比值才能较全面地说明一幅图像质量受噪声影响的程度。可以求得△M的量化信噪比为：$\frac{S}{\bar N_q} = \frac{3}{8\pi^2}·\frac{f_s^3}{f^2_c·f_m} $。

### DPCM编码

 预测编码的另一种有用的形式是DPCM编码(Differential Pulse Code Modulation)。

这实际上是△M和PCM两种技术相结合的编码方法。

#### PCM编码和解码原理（略）

PCM可在通信系统中完成将信号数字化功能。
PCM的实现主要包括三个步骤完成：抽样、量化、编码。分别完成时间上离散、幅度上离散、及量化信号的二进制表示。根据CCITT的建议，为改善小信号量化性能，采用压扩非均匀量化，有两种建议方式，分别为A律和μ律方式，我国采用了A律方式，由于A律压缩实现复杂，常使用 13 折线法编码,采用非均匀量化PCM编码。

#### DPCM有损预测编码

- 在卡特勒的专利中提出利用积分器根据一行上前样本值预测现样本值，并且把现样本值与其估计值的差值进行量化和编码。这就是DPCM的基本设计思想。
- DPCM编码器原理框图由取样器、比较器、量化器、预测器、编码器五个部分组成。

![DPCM1](../../../../../%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/DPCM1.png)

##### 编码过程

- 输入信号f(t)经采样后将样值送入比较器，使得f(t)与预测值相减得出误差信号，即$e(t)=f(t)-\hat f(t)$。
- 然后，将e(t)送入量化器量化为Ｍ个电平之一  $m=2^N$ ，
- 量化后的样值再送入PCM编码器中编码，以便传输。
- 另外一路是将e(t)送入相加器，在这里e(t)与$\hat f(t)$相加后再送入预测器，以便预测下一个样值。

##### 译码过程

- 译码器收到码字后首先经PCM译码，
- 得到e(t)后再送入相加器与预测值$\hat f(t)$相机得到f(t)。
- 另外，f(t)又送到预测器以便预测下一个样值。

#### △M编码与DPCM编码区别

- △M实际上是一位二进制码的差分脉码调制，也就是用1bit码来表示增量值。
- 而DPCM是N位二进码来表示e(t)值的编码法。 

#### 量化信噪比

![DPCM信噪比](../../../../../%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/DPCM%E4%BF%A1%E5%99%AA%E6%AF%94.png)

![DPCM信噪比2](../../../../../%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/DPCM%E4%BF%A1%E5%99%AA%E6%AF%942.png)

#### 量化与预测

- 在所有有损预测压缩中都会出现误差。误差的严重程度取决于使用的量化方法和预测方法之间的相互作用
- 尽管存在这种相互作用
  - 定义预测函数时仍然假定没有量化误差
  - 定义量化函数时仅是尽可能地降低它自身的误差
  - 即量化函数和预测函数是分别定义的

#### 最佳线性预测

采用均方误差（MSE）为极小值的准则来获得DPCM，称为最佳线性预测，亦即此时预测误差最小。对于图像来说，最佳线性预测的关键就是求出各个预测系数，使得预测误差最小，从而使得接收图像和原图像差别最小。 

##### 自适应预测编码

1. 自适应预测

   ![自适应预测](../../../../../%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E8%87%AA%E9%80%82%E5%BA%94%E9%A2%84%E6%B5%8B.png)

2. 自适应量化

   根据信号局部区域的特点，自适应地修改和调整量化器参数，包括量化器输出的动态范围，量化器判决电平（量化步长）等。实际上是在量化器分层确定后，当预测误差值小时，将量化器的输出动态范围减小，量化步长减小；当预测误差大时，将量化器的输出范围扩大，量化器步长扩大。

## 统计编码（重点）

### 简介

统计编码是指建立在图像统计特性基础之上的一类压缩编码方法，根据信源的概率分布特性，分配不同长度的码字，降低平均码字长度，以提高传输速度，节省存储空间。

#### 香农范诺编码

- 产生编码长度可变的码字，以缩小冗余
- 计算信源中每个符号发生的频率，为出现频率高的符号分配较短的码字。

- 编码方法：
  - 计算每个符号发生的频率；
  - 将符号集分为两个子集，使两边的频率之和近似相等；
  - 分别赋值0，1；
  - 重复步骤2，3；

- 例子：![香农范诺编码例子](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E9%A6%99%E5%86%9C%E8%8C%83%E8%AF%BA%E7%BC%96%E7%A0%81%E4%BE%8B%E5%AD%90.png)

#### 定长编码

- 定义：采用相同长度的不同码字去代表一个消息集合中的不同消息
- K-比特编码支持$2^k$个不同的符号
- 例子 - ASCII码
  - 1967年由美国制定的字符编码，对英语字符与二进制位之间的关系做了统一规定，并一直沿用至今
  - bits/char = 8，即一字节(byte)

#### 不定长编码

- 定义：对一个消息集合中的不同消息，采用不同长度的码字表示
- 为常用的消息分配较短的码字，提高编码效率
- 例子 – 摩尔斯密码
  - 短促点信号“.”，长信号“—”
  - 为常用字母使用较短的码字（A，E）
  - …---… 怎样解码？**——解码会产生歧义**
    - SOS
    - IAMIE
    - EEWNI
    - V70

#### 唯一可译

单义可译码定义：若W中任一有限长的码字序列（即有限长的一串W），可唯一的分割成一个一个码字，称为单义可译或唯一可译，W也叫做单义代码。

- 定长编码
  译码简单且具有唯一性，但编码长度并不是最短的
- 不定长编码
  编码长度更短，但需要保证编码是唯一可译的

哈夫曼编码就是一种巧妙的保证了唯一可译性变长编码。

##### 保证单义可译

- Kraft不等式：

  长度为$L_1,L_2,\cdots,L_n$的m进制唯一可译码存在的充分必要条件是：
  $$
  \sum^n_{i=1}m^{-L_i} \le 1
  $$
  含义：要求$L_i$比较大（码长不能过短），意味着码字可能的组合数多，不为别的码字的字首。

  - 不满足Kraft不等式的码肯定不是唯一可译码，而满足的也不一定就是唯一可译的。

- 方法一：每个码字后加一个特殊结束符。虽然可以解决问题，但是编码效率低。

- 方法二：非续长码字(prefix-free)：确保任一码字都不是由另一个码字加上若干个码元所构成。莫斯密码就不是非续长码字。

  - 定义：任一码字都不是由另一个码字加上若干个码元所构成
  - 方法 ：二叉树
    - 每个叶子节点代码一个符号
    - 编码是通向叶子节点的路径

#### 平均码长

$$
l = \sum^n_{j=1}P(a_j)L_j \\
P(a_j):a_j出现的概率\\
L_j:a_j编码后的码长
$$

#### 编码极限

##### 香农信息论

- 现代信息论研究的开端
  用数学方法对信息进行量化
- 编码冗余（信号出现频率存在差异）
  一组数据携带的平均信息量决定了编码的极限。

##### 信息量(information content)

略。

### 哈夫曼编码（重点）

- 基本原理：

  将在图像中出现次数多的像素值给一个短的编码，将出现次数少的像素值给一个长的编码。

- Huffman码表的建立步骤: 

1. 将信源符号按出现概率从大到小排成一列，然后把最末两个符号的概率相加，合成一个概率。 
2. 把这个符号的概率与其余符号的概率按从大到小排列，然后再把最末两个符号的概率加起来，合成一个概率。 
3. 重复上述做法，直到最后剩下两个概率为止。 
4. 从最后一步剩下的两个概率开始逐步向前进行编码。每步只需对两个分支各赋予一个二进制码，如对概率大的赋予码0，对概率小的赋予码1。 

- 哈夫曼编码并不唯一：
  - 每次对分支节点的符号分配“0”和“1”码元是任意的，所以可得到不同的码字
  - 虽然得到的具体码字不同，但平均码长也不变，所以没有本质区别；
  - 为了使得到的哈夫曼树的结构尽量唯一，**通常规定生成的哈夫曼树中每个结点的左子树根结点的权小于等于右子树根结点的权。**
- 如果在源数据中所有符号出现的概率是独立的，哈夫曼编码中每个符号的平均比特数 ≤ (H(M) + 1)

### 算术编码（重点）

- 基本原理
  将编码的信息表示成实数0和1之间的一个间隔，信息越长编码表示它的间隔就越小，表示这一间隔所需要的二进制位就越多。

- 例子：

  ![算术编码](数字图像.assets/算术编码.png)

- 评价：

  - 算术编码是一种非分组编码，编码方案众多，压缩效率最高。当信源符号概率接近是，建议用算术编码；
  - 算术编码比哈夫曼编码复杂，需要缓冲储存器，硬件实现困难；
  - 比分组码的误差扩散更严重，要求有高质量的信道，或采用检错重发的方式；
  - 概率大的符号对应区间大，描述所需比特少。随着输入序列长度增加，平均编码所用比特数趋向于信源熵。

### 行程编码

- 连续的、具有相同灰度值的一些象素组成的序列称为一个行程。在编码时， 对于每个行程只存储一个灰度值的码，再紧跟着存储这个行程的长度。 
- 适用于有较多灰度相同对象的图像，例如海洋、湖泊的卫星图像，医学图像 中的细胞，染色体，材料的显微图像等。 
- 编码方式：
  - 控制符 + 重复次数 + 被重复字符
  - 重复字符大于等于4时才进行编码

![行程编码1](数字图像.assets/行程编码1.png)

![行程编码2](数字图像.assets/行程编码2.png)

## 变换编码

### 基本原理

![变换编码基本原理](数字图像.assets/变换编码基本原理.png)

### 主要解决的问题

1．选择变换方法
2．确定子块图像的大小
3．变换系数的编码 

### 特点及应用

- 思想
   正变换得到的系数矩阵中，数值较大的方差总是集中在少数系数中。通常，大幅度系数集中在低频率区，而且图像相关性明显下降，对较少的系统可分配少的比特数或不传送。故正交变换本身只是把分布在变换域中的信息变得集中起来，为合理少分配给某些数据比特数提供了可能。   
- 块状效应
   块状效应是指当压缩比提高到一定程度后，在相邻图像块的边界处，会出现可见的不连续性，这会使观察者有非常不舒服的感觉。
-  ![变换编码1](数字图像.assets/变换编码1.png)

### 块变换编码

- 块变换编码：把图像分成大小相等且不重叠的小块，对每块单独进行编码。![](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E5%9D%97%E5%8F%98%E6%8D%A2%E7%BC%96%E7%A0%811.png)
- 编码过程：![](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E5%9D%97%E5%8F%98%E6%8D%A2%E7%BC%96%E7%A0%812.png)

## 位平面编码

### 位平面分解

![位平面编码1](数字图像.assets/位平面编码1.png)

![位平面编码2](数字图像.assets/位平面编码2.png)

### 位平面编码

位平面分解之后，每个位平面都是二值图像，编码方法有1-D游程编码，2-D游程编码，常数块编码和边界跟踪编码等方法。 

## JPEG压缩编码（重点）

![jpeg1](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/jpeg1.png)

![jpeg2](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/jpeg2.png)

### 主要计算步骤 

1. 正向离散余弦变换(FDCT)
2. 量化(quantization) (这一步出现了信息的损失) 
3. Z字形编码(Zigzag scan)。 
4. 使用差分脉冲编码调制(DPCM)对直流系数(DC)进行编码 
5. 使用行程长度编码(RLE)对交流系数(AC)进行编码 
6. 熵编码(entropy coding) 

# 9 形态学图像处理（重点）

## 预备知识

反射与平移广泛用来表达基于结构元的操作。

### 反射

集合B的反射$\hat B$：定义为$\hat B = \{w|w=-b,b \in B\}$，即关于原集合原点对称。

### 平移

集合A的平移$A_z$：集合A平移到点$z=(z_1,z_2)$，表示为$A_z$，定义为$A_z=\{c|c=a+z,a\in A\}$。

![](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E5%8F%8D%E5%B0%84%E5%B9%B3%E7%A7%BB.png)

### 击中与击不中

设有两幅图像A和B，如果$A\cap B \ne \varnothing$，那么称B击中A，记为$B\uparrow A$；否则如果$A\cap B = \varnothing$，那么称B击不中A。（通常A为背景、B为前景）

![](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E5%87%BB%E4%B8%AD.png)

### 二值图像逻辑操作

![](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C.png)

## 腐蚀与膨胀（重点）

### 结构元

**结构元**：研究一幅图像中感兴趣特性所使用的小集合或子图像。

结构元通常关于原点元素对称，且成矩形阵列。

- 二值形态学中的运算对象是集合。设A为图像集合，S为结构元，形态学运算就是**用S对A进行操作**。
- **实际上结构元本身也是一个图像集合**。对每个结构元可以指定一个**原点**，它是结构元素参与形态学运算的**参考点**。
- 应注意，**原点可以包含在结构元中，也可以不包含在结构元**中，但**运算的结果常不相同**。
- 二值形态学中两个最基本的运算是腐蚀与膨胀。

![结构元](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E7%BB%93%E6%9E%84%E5%85%83.png)

### 腐蚀

使图像缩小。

#### 定义

假定A和B是$Z^2$上的两个集合，A被B腐蚀定义为：
$$
A \ominus B = \{z|(B)_z \subseteq A\}
$$
集合B称为结构元。

A被B腐蚀的结果是所有使B平移Z后仍在A中的元素的集合。

==换句话说，用B来腐蚀A得到的集合是*B中元素完全包括在A中时***B的原点位置的集合**。==

#### 运算原理示例

![腐蚀](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E8%85%90%E8%9A%80.png)

#### 算法

1. 用结构元素B(如3x3)，扫描图像A的每一个像素。
2. 用**结构元素**与其**覆盖的二值图像**做**“与”操作**。
3. 再根据计算的结果**对结构元素原点对应的图像象素置值**。
4. 如果**都为1**（结构相同），结果**图像中与B的原点位置对应的像素值标注为1**；否则为0。

#### 应用

- 腐蚀在数学形态学运算中的作用是**消除物体边界点**。
- 如果结构元素取3×3的像素块，腐蚀将使物体的边界沿周边减少一个像素。



1. 腐蚀可以把小于结构元素的物体(毛刺、小凸起)去除，这样选取不同大小的结构元素，就可以在原图像中去掉不同大小的物体。产生滤波器的作用。
2. 消除物体边界点：如果两个物体之间有细小的连通，那么当结构元素足够大时， 通过腐蚀运算可以将两个物体分开。

### 膨胀

使图像扩大。

#### 定义

A和B是$Z^2$中的集合，A被B膨胀定义为：
$$
A \oplus B = \{z|(\hat B)_z \cap A \ne \varnothing)\}\\
或\\
A \oplus B = \{z|[(\hat B)_z \cap A] \subseteq A)\}
$$
集合B通常叫做膨胀结构元。

- 上式表示：B的反射进行平移与A的交集不为空；
- B的反射：相对于自身原点的映象；
- **注意：是B的反射进行操作。**

#### 运算原理示例

B膨胀A的过程：先对结构元素B做关于原点的映射 $\hat B$ ，再将 $\hat B$  平移z， $\hat B$和A至少有1个非零元素相交时**B的原点位置的集合**。

![膨胀](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E8%86%A8%E8%83%80.png)

![膨胀2](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E8%86%A8%E8%83%802.png)

#### 算法

1. 将结构元素**B反射后的原点**移至集合A的某一点；
2. 用结构元素与其覆盖的二值图像做**“或”操作**；
3. 再据计算结果对**结构元原点对应的图像象素置值**；
4. 如果**都为0，结果图像该像素为0**，否则为1；
5. 对集合中所有元素重复该过程。

#### 应用

1. 将裂缝接起来的形态学膨胀。
2. 和腐蚀一起使用，可以做到图形筛选：先腐蚀去掉不要的，再膨胀恢复所需要的。

#### 对偶性

膨胀和腐蚀彼此关于集合求补运算和反射运算是对偶的，即：
$$
(A \ominus B )^C = A^C \oplus \hat B \\
(A \oplus B )^C = A^C \ominus \hat B \\
$$

## 开操作和闭操作（重点）

### 开操作

**先用B对A进行腐蚀，然后用B对结果膨胀。**

开操作作用：使图像的轮廓变得光滑，断开狭窄的间断和消除细的突出物。

#### 定义

使用结构元素B对集合A进行开操作，定义为：
$$
A \circ B = (A\ominus B)⊕ B
$$
含义：先用B对A腐蚀，然后用B对结果膨胀。

另一个定义：
$$
  A\circ B = ∪\{(B)_z| (B)_z ⊆ A\}
$$

#### 几何解释

- $A\circ B$的边界通过B中的点完成；
- **B在A的边界内转动时，B中的点所能到达的A的边界的最远点**。
- ![开操作](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E5%BC%80%E6%93%8D%E4%BD%9C.png)

#### 示例

![开操作示例](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E5%BC%80%E6%93%8D%E4%BD%9C%E7%A4%BA%E4%BE%8B.png)

#### 性质

1. $A\circ B$是A的子集合；
2. 如果C是D的子集，则$C\circ B$是$D\circ B$的子集；
3. $(A\circ B) \circ B= A \circ B$；

### 闭操作

**先用B对A膨胀，然后用B对结果腐蚀。**

闭操作作用：同样使图像的轮廓变得光滑，但与开操作相反，它用来填充物体内细小空洞、连接邻近物体、平滑其边界的同时并不明显改变其面积。

#### 定义

使用结构元素B对集合A进行闭操作，定义为：
$$
A\bullet B = (A⊕ B)\ominus B \\
或\\
A\bullet B = \cup\{(B)_z|(B)_z \cap A \ne \varnothing\}
$$
含义：先用B对A膨胀，然后用B对结果腐蚀。

#### 几何解释

- AoB的边界通过B中的点完成；
- B在A的边界外转动时，B中的点所能到达的A的边界的最远点。
- ![闭操作几何解释](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E9%97%AD%E6%93%8D%E4%BD%9C%E5%87%A0%E4%BD%95%E8%A7%A3%E9%87%8A.png)

#### 示例

![闭操作示例](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E9%97%AD%E6%93%8D%E4%BD%9C%E7%A4%BA%E4%BE%8B.png)

#### 性质

1. A是A•B的子集合；
2. 如果C是D的子集，则C•B是D•B的子集；
3. (A•B)•B= A•B

### 开操作和闭操作联合应用

应用：先开操作再闭操作，构成噪声滤波器。

![开闭操作](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E5%BC%80%E9%97%AD%E6%93%8D%E4%BD%9C.png)

1. a图是受噪声污染的指纹二值图像，噪声为黑色背景上的亮元素和亮指纹部分的暗元素。
2. b图是使用的结构元素。
3. c图是使用结构元素对图a腐蚀的结果：黑色背景噪声消除了，指纹中的噪声尺寸增加。
4. d图是用结构元对图c膨胀的结果：包含于指纹中的噪声分量的尺寸被减小或被完全消除，但在指纹纹路间产生了新的间断。
5. e图是对图d膨胀的结果，图d的大部分间断被恢复，但指纹的线路变粗了。
6. f图是对图e腐蚀的结果，即对图d中开操作的闭操作。最后结果消除了噪声斑点。

## 其他·待定



# 10 图像分割和边缘检测（重点）

## 基本知识

- 图像分割的目标是重点根据图像中的物体将图像的像素分类，并提取感兴趣目标。
- 图像分割是图像识别和图像理解的基本前提步骤。
- 针对单色图像的分割算法基于处理灰度值的两类特性之一：不连续性和相似性。
- 分类—分割依据：
  - **相似性分割**——区域：将相似灰度级的像素聚集在一起。形成图像中的不同区域。这种基于相似性原理的方法也称为**基于区域相关**的分割技术。
  - **非连续性分割**——边界：首先检测局部不连续性，然后将它们连接起来形成边界，这些边界把图像分以不同的区域。这种基于不连续性原理检出物体边缘的方法称为**基于点相关**的分割技术。
  - 两种方法是互补的。有时将它们结合起来，以求得到更好的分割效果。
- 图像分割的基本策略是基于灰度值的两个基本特性：
  - 区域之间的不连续性：
    - 先找到点、线（宽度为1）、边（不定宽度）
    - 再确定区域
  - 区域内部的相似性
    - 通过选择阈值，找到灰度值相似的区域
    - 区域的外轮廓就是对象的边

## 边缘检测

### 点检测

- 用空域的高通滤波器来检测孤立点

![](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E7%82%B9%E6%A3%80%E6%B5%8B.png)

- 若 R = 0 说明被检测区域各点灰度值相同。
- 若 R > T 说明被检测区域响应该高通滤波器，即该检测区域有孤立点。

### 线检测

- 通过比较典型模版的计算值，确认一个点是否在某个方向的线上。

- 设计模版：

  - 模版系数之和为0
  - 感兴趣的方向系数值较大

  ![](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E7%BA%BF%E6%A3%80%E6%B5%8B.png)

- 用不同模版分别计算，从这些值中寻找绝对值最大值，确定当前点更加接近于该模版所对应的直线。

### 边缘检测

- 物体的边缘是以图像局部特性的不连续性的形式出现的，从本质上说，边缘意味着一个区域的终结和另一个区域的开始。
- 图像边缘信息在图像分析和人的视觉中都是十分重要的，是图像识别中提取图像特征的一个重要属性。

#### 边缘导数

边缘上的这种变化可以通过微分算子进行检测：

##### 一阶导数

$$
\frac{\partial f}{\partial x}=f(x+1)-f(x)
$$



- 通过梯度进行计算
- 特点：对于亮的边，边的变化起点是正的，结束是负的。对于暗边，结论相反。常数部分为零。
- 用途：用于检测图像中边的存在。

##### 二阶导数

- 一个二维图像函数的拉普拉斯算子定义为：
  $$
  \nabla ^2f=\frac{\partial^2f}{\partial x^2}+\frac{\partial ^2f}{\partial y^2}
  $$

  - 在x方向上：
    $$
    \frac{\partial ^2f}{\partial x^2}=f(x+1,y)+f(x-1,y)-2f(x,y)
    $$

  - 在y方向上：
    $$
    \frac{\partial ^2f}{\partial y^2}=f(x,y+1)+f(x,y-1)-2f(x,y)
    $$

  - 所以有：
    $$
    \nabla ^2f(x,y)=f(x+1,y)+f(x-1,y)+f(x,y+1)+f(x,y-1)-4f(x,y)
    $$







- 通过拉普拉斯算子来计算

![](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E8%BE%B9%E7%BC%98%E5%AF%BC%E6%95%B0.png)

#### 简单边缘检测方法

- 最早的边缘检测方法都是基于像素的数值导数的，在数字图像中应用差分代替导数运算。

- 差分定义：
  $$
  \Delta_xf(i,j)=f(i,j)-f(i-1,j)\\
  \Delta_yf(i,j)=f(i,j)-f(i,j-1)\\
  $$







- 即使用一阶导数的边缘检测滤波器。

#### 边缘检测问题

- 问题：
  - 图像中存在太多的细节。
  - 图像受到噪声的干扰，不能准确的检测边缘。
- 一个解决方法：在边缘检测之前对图像进行平滑。先用高斯函数进行平滑（对图像进行线性平滑，在数学上是进行卷积）再提出用拉普拉斯算子来代替以减少后期的运算量。

#### Laplacian边缘检测

Laplacian边缘检测——即高斯拉普拉斯(Laplacian of Gaussian，LOG，或Mexican hat，墨西哥草帽 )滤波器。

- Laplacian由于对噪声太敏感，因此一般不单独使用，通常和平滑(Gaussian)高斯滤波器进行结合来进行边缘检测，**即高斯拉普拉斯(Laplacian of Gaussian，LOG，或Mexican hat，墨西哥草帽 )滤波器。**

  ![](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E9%AB%98%E6%96%AF%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF.png)

### Hough变换

Hough(霍夫)变换可以用于将边缘像素连接起来得到边界曲线，它的主要优点在于受噪声和曲线间断的影响较小。

![hough](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/hough.png)

![hough2](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/hough2.png)

![hough3](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/hough3.png)

## 图像分割

### 阈值法

- 图像分割的的经典方法是基于灰度阈值的分割方法。

![阈值1](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E9%98%88%E5%80%BC1.png)

#### 全局阈值

- 全局阈值是指整幅图像使用同一个阈值做分割处理，并产生一个二值图，区分出前景对象和背景。
- 适用于背景和前景对比度大的图像
- 算法实现：
  - 选取一个合适的阈值T，逐行扫描图像
  - 凡灰度级大于T的，颜色置为255；凡灰度级小于T的，颜色置为0。
- 如何选取阈值，以下有人工和自动选取两种方式。

##### 人工阈值

通过人眼的观察，在分析图像直方图的基础上，人工选出合适的阈值。也可也在人工选出阈值后，根据分割效果，不断地交互操作，从而选择出最佳的阈值。

##### 自动阈值——迭代法

- 开始时选择一个阈值作为初始估计值，然后按某种策略不断选择新的阈值。

- 关键在于选什么样的阈值改进策略，好的阈值改进策略应该具备两个特征，一是能够快速收敛，二是在每一次迭代过程中，新产生阈值优于上一次的阈值。

- 基本全局阈值T可以按如下计算：

  ![](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E8%87%AA%E5%8A%A8%E9%98%88%E5%80%BC-%E8%BF%AD%E4%BB%A3.png)

##### 自动阈值——OSTU方法

![](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/ostu.png)

#### 单值阈值的问题

- 只能对双峰的直方图有较好的工作效果。
- 对于其他类型的直方图，需要更多的阈值。
- 不均匀的光照会使单值阈值方案失效。

#### 自动阈值——分水岭算法

![](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E5%88%86%E6%B0%B4%E5%B2%AD1.png)

![](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E5%88%86%E6%B0%B4%E5%B2%AD2.png)

![](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E5%88%86%E6%B0%B4%E5%B2%AD3.png)

![](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E5%88%86%E6%B0%B4%E5%B2%AD4.png)

- 改进的分水岭算法：

  ![](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E5%88%86%E6%B0%B4%E5%B2%AD5.png)

### 区域分割

- 阈值分割法由于没有或很少考虑空间关系，使多阈值选择受到限制
- 基于区域的分割方法可以弥补，它利用的是图像的空间性质，该方法认为分割出来的属性同一区域的像素应具有相似的性质。
- 传统的区域分割算法有区域增长法和区域分割合并法。该类方法在没有先验知识可以利用时，对含有复杂场景或自然景物等先验知识不足的图像进行分割，也可以取得较好的性能。但是，空间和时间开销都比较大。

#### 区域生长

分割的目的是把一副图像划分成一些区域，最直接的方法就是把一幅图像分成满足某种判据的区域，即将点组成区域。为了实现分组，首先要确定区域的数目，其次要确定一个区域与其他区域相区别的特征，最后还要产生有意义分割的相似性判据。

##### 基本思路

![](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E5%8C%BA%E5%9F%9F%E7%94%9F%E9%95%BF.png)

##### 基本步骤

1. 选择合适的种子点
2. 确定相似性准则（生长准则）
3. 确定生长停止条件

##### 过程

- 从满足检测准则的点开始（或者已知点）在各个方向上生长出区域。
- 例如：每一步所接受的邻近点的灰度级与种子点的灰度级**相差绝对值小于等于T**。

![](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E5%8C%BA%E5%9F%9F%E7%94%9F%E9%95%BF2.png)