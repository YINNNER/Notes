# 8 图像压缩（重点）

## 概述

### 编码的定义

![编码定义](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E7%BC%96%E7%A0%81%E5%AE%9A%E4%B9%89.png)

- 无损压缩常用方法：统计编码。利用消息或消息序列出现概率的分布特性，注重寻找概率与码字长度间的最优匹配。

## 预测编码

## 统计编码（重点）

### 简介

统计编码是指建立在图像统计特性基础之上的一类压缩编码方法，根据信源的概率分布特性，分配不同长度的码字，降低平均码字长度，以提高传输速度，节省存储空间。

#### 香农范诺编码

- 产生编码长度可变的码字，以缩小冗余
- 计算信源中每个符号发生的频率，为出现频率高的符号分配较短的码字。
- 例子：![香农范诺编码例子](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E9%A6%99%E5%86%9C%E8%8C%83%E8%AF%BA%E7%BC%96%E7%A0%81%E4%BE%8B%E5%AD%90.png)

#### 定长编码

- 定义：采用相同长度的不同码字去代表一个消息集合中的不同消息
- K-比特编码支持$2^k$个不同的符号
- 例子 - ASCII码
  - 1967年由美国制定的字符编码，对英语字符与二进制位之间的关系做了统一规定，并一直沿用至今
  - bits/char = 8，即一字节(byte)

#### 不定长编码

- 定义：对一个消息集合中的不同消息，采用不同长度的码字表示
- 为常用的消息分配较短的码字，提高编码效率
- 例子 – 摩尔斯密码
  - 短促点信号“.”，长信号“—”
  - 为常用字母使用较短的码字（A，E）
  - …---… 怎样解码？**——解码会产生歧义**
    - SOS
    - IAMIE
    - EEWNI
    - V70

#### 唯一可译

- 定长编码
  译码简单且具有唯一性，但编码长度并不是最短的
- 不定长编码
  编码长度更短，但需要保证编码是唯一可译的

哈夫曼编码就是一种巧妙的保证了唯一可译性变长编码。

#### 平均码长

$$
l = \sum^n_{j=1}P(a_j)L_j \\
P(a_j):a_j出现的概率\\
L_j:a_j编码后的码长
$$

#### 编码极限

##### 香农信息论

- 现代信息论研究的开端
  用数学方法对信息进行量化
- 编码冗余（信号出现频率存在差异）
  一组数据携带的平均信息量决定了编码的极限。

##### 信息量

### 哈夫曼编码（重点）

- 基本原理：

  将在图像中出现次数多的像素值给一个短的编码，将出现次数少的像素值给一个长的编码。

- Huffman码表的建立步骤: 

1. 将信源符号按出现概率从大到小排成一列，然后把最末两个符号的概率相加，合成一个概率。 
2. 把这个符号的概率与其余符号的概率按从大到小排列，然后再把最末两个符号的概率加起来，合成一个概率。 
3. 重复上述做法，直到最后剩下两个概率为止。 
4. 从最后一步剩下的两个概率开始逐步向前进行编码。每步只需对两个分支各赋予一个二进制码，如对概率大的赋予码0，对概率小的赋予码1。 

### 算术编码（重点）

### 行程编码

- 连续的、具有相同灰度值的一些象素组成的序列称为一个行程。在编码时， 对于每个行程只存储一个灰度值的码，再紧跟着存储这个行程的长度。 
- 适用于有较多灰度相同对象的图像，例如海洋、湖泊的卫星图像，医学图像 中的细胞，染色体，材料的显微图像等。 

## 变换编码

### 块变换编码

- 块变换编码：把图像分成大小相等且不重叠的小块，对每块单独进行编码。![](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E5%9D%97%E5%8F%98%E6%8D%A2%E7%BC%96%E7%A0%811.png)
- 编码过程：![](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E5%9D%97%E5%8F%98%E6%8D%A2%E7%BC%96%E7%A0%812.png)

## 位平面编码

## JPEG压缩编码（重点）

![jpeg1](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/jpeg1.png)

![jpeg2](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/jpeg2.png)

### 主要计算步骤 

1. 正向离散余弦变换(FDCT)
2. 量化(quantization) (这一步出现了信息的损失) 
3. Z字形编码(Zigzag scan)。 
4. 使用差分脉冲编码调制(DPCM)对直流系数(DC)进行编码 
5. 使用行程长度编码(RLE)对交流系数(AC)进行编码 
6. 熵编码(entropy coding) 

# 9 形态学图像处理（重点）

## 预备知识

反射与平移广泛用来表达基于结构元的操作。

### 反射

集合B的反射$\hat B$：定义为$\hat B = \{w|w=-b,b \in B\}$，即关于原集合原点对称。

### 平移

集合A的平移$A_z$：集合A平移到点$z=(z_1,z_2)$，表示为$A_z$，定义为$A_z=\{c|c=a+z,a\in A\}$。

![](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E5%8F%8D%E5%B0%84%E5%B9%B3%E7%A7%BB.png)

### 击中与击不中

设有两幅图像A和B，如果$A\cap B \ne \varnothing$，那么称B击中A，记为$B\uparrow A$；否则如果$A\cap B = \varnothing$，那么称B击不中A。（通常A为背景、B为前景）

![](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E5%87%BB%E4%B8%AD.png)

### 二值图像逻辑操作

![](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C.png)

## 腐蚀与膨胀（重点）

### 结构元

**结构元**：研究一幅图像中感兴趣特性所使用的小集合或子图像。

结构元通常关于原点元素对称，且成矩形阵列。

- 二值形态学中的运算对象是集合。设A为图像集合，S为结构元，形态学运算就是**用S对A进行操作**。
- **实际上结构元本身也是一个图像集合**。对每个结构元可以指定一个**原点**，它是结构元素参与形态学运算的**参考点**。
- 应注意，**原点可以包含在结构元中，也可以不包含在结构元**中，但**运算的结果常不相同**。
- 二值形态学中两个最基本的运算是腐蚀与膨胀。

![结构元](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E7%BB%93%E6%9E%84%E5%85%83.png)

### 腐蚀

使图像缩小。

#### 定义

假定A和B是$Z^2$上的两个集合，A被B腐蚀定义为：
$$
A \ominus B = \{z|(B)_z \subseteq A\}
$$
集合B称为结构元。

A被B腐蚀的结果是所有使B平移Z后仍在A中的元素的集合。

==换句话说，用B来腐蚀A得到的集合是*B中元素完全包括在A中时***B的原点位置的集合**。==

#### 运算原理示例

![腐蚀](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E8%85%90%E8%9A%80.png)

#### 算法

1. 用结构元素B(如3x3)，扫描图像A的每一个像素。
2. 用**结构元素**与其**覆盖的二值图像**做**“与”操作**。
3. 再根据计算的结果**对结构元素原点对应的图像象素置值**。
4. 如果**都为1**（结构相同），结果**图像中与B的原点位置对应的像素值标注为1**；否则为0。

#### 应用

- 腐蚀在数学形态学运算中的作用是**消除物体边界点**。
- 如果结构元素取3×3的像素块，腐蚀将使物体的边界沿周边减少一个像素。



1. 腐蚀可以把小于结构元素的物体(毛刺、小凸起)去除，这样选取不同大小的结构元素，就可以在原图像中去掉不同大小的物体。产生滤波器的作用。
2. 消除物体边界点：如果两个物体之间有细小的连通，那么当结构元素足够大时， 通过腐蚀运算可以将两个物体分开。

### 膨胀

使图像扩大。

#### 定义

A和B是$Z^2$中的集合，A被B膨胀定义为：
$$
A \oplus B = \{z|(\hat B)_z \cap A \ne \varnothing)\}\\
或\\
A \oplus B = \{z|[(\hat B)_z \cap A] \subseteq A)\}
$$
集合B通常叫做膨胀结构元。

- 上式表示：B的反射进行平移与A的交集不为空；
- B的反射：相对于自身原点的映象；
- **注意：是B的反射进行操作。**

#### 运算原理示例

B膨胀A的过程：先对结构元素B做关于原点的映射 $\hat B$ ，再将 $\hat B$  平移z， $\hat B$和A至少有1个非零元素相交时**B的原点位置的集合**。

![膨胀](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E8%86%A8%E8%83%80.png)

![膨胀2](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E8%86%A8%E8%83%802.png)

#### 算法

1. 将结构元素**B反射后的原点**移至集合A的某一点；
2. 用结构元素与其覆盖的二值图像做**“或”操作**；
3. 再据计算结果对**结构元原点对应的图像象素置值**；
4. 如果**都为0，结果图像该像素为0**，否则为1；
5. 对集合中所有元素重复该过程。

#### 应用

1. 将裂缝接起来的形态学膨胀。
2. 和腐蚀一起使用，可以做到图形筛选：先腐蚀去掉不要的，再膨胀恢复所需要的。

#### 对偶性

膨胀和腐蚀彼此关于集合求补运算和反射运算是对偶的，即：
$$
(A \ominus B )^C = A^C \oplus \hat B \\
(A \oplus B )^C = A^C \ominus \hat B \\
$$

## 开操作和闭操作（重点）

### 开操作

**先用B对A进行腐蚀，然后用B对结果膨胀。**

开操作作用：使图像的轮廓变得光滑，断开狭窄的间断和消除细的突出物。

#### 定义

使用结构元素B对集合A进行开操作，定义为：
$$
A \circ B = (A\ominus B)⊕ B
$$
含义：先用B对A腐蚀，然后用B对结果膨胀。

另一个定义：
$$
  A\circ B = ∪\{(B)_z| (B)_z ⊆ A\}
$$

#### 几何解释

- $A\circ B$的边界通过B中的点完成；
- **B在A的边界内转动时，B中的点所能到达的A的边界的最远点**。
- ![开操作](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E5%BC%80%E6%93%8D%E4%BD%9C.png)

#### 示例

![开操作示例](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E5%BC%80%E6%93%8D%E4%BD%9C%E7%A4%BA%E4%BE%8B.png)

#### 性质

1. $A\circ B$是A的子集合；
2. 如果C是D的子集，则$C\circ B$是$D\circ B$的子集；
3. $(A\circ B) \circ B= A \circ B$；

### 闭操作

**先用B对A膨胀，然后用B对结果腐蚀。**

闭操作作用：同样使图像的轮廓变得光滑，但与开操作相反，它用来填充物体内细小空洞、连接邻近物体、平滑其边界的同时并不明显改变其面积。

#### 定义

使用结构元素B对集合A进行闭操作，定义为：
$$
A\bullet B = (A⊕ B)\ominus B \\
或\\
A\bullet B = \cup\{(B)_z|(B)_z \cap A \ne \varnothing\}
$$
含义：先用B对A膨胀，然后用B对结果腐蚀。

#### 几何解释

- AoB的边界通过B中的点完成；
- B在A的边界外转动时，B中的点所能到达的A的边界的最远点。
- ![闭操作几何解释](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E9%97%AD%E6%93%8D%E4%BD%9C%E5%87%A0%E4%BD%95%E8%A7%A3%E9%87%8A.png)

#### 示例

![闭操作示例](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E9%97%AD%E6%93%8D%E4%BD%9C%E7%A4%BA%E4%BE%8B.png)

#### 性质

1. A是A•B的子集合；
2. 如果C是D的子集，则C•B是D•B的子集；
3. (A•B)•B= A•B

### 开操作和闭操作联合应用

应用：先开操作再闭操作，构成噪声滤波器。

![开闭操作](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E5%BC%80%E9%97%AD%E6%93%8D%E4%BD%9C.png)

1. a图是受噪声污染的指纹二值图像，噪声为黑色背景上的亮元素和亮指纹部分的暗元素。
2. b图是使用的结构元素。
3. c图是使用结构元素对图a腐蚀的结果：黑色背景噪声消除了，指纹中的噪声尺寸增加。
4. d图是用结构元对图c膨胀的结果：包含于指纹中的噪声分量的尺寸被减小或被完全消除，但在指纹纹路间产生了新的间断。
5. e图是对图d膨胀的结果，图d的大部分间断被恢复，但指纹的线路变粗了。
6. f图是对图e腐蚀的结果，即对图d中开操作的闭操作。最后结果消除了噪声斑点。

## 其他·待定



# 10 图像分割和边缘检测（重点）

## 基本知识

- 图像分割的目标是重点根据图像中的物体将图像的像素分类，并提取感兴趣目标。
- 图像分割是图像识别和图像理解的基本前提步骤。
- 针对单色图像的分割算法基于处理灰度值的两类特性之一：不连续性和相似性。
- 分类—分割依据：
  - **相似性分割**——区域：将相似灰度级的像素聚集在一起。形成图像中的不同区域。这种基于相似性原理的方法也称为**基于区域相关**的分割技术。
  - **非连续性分割**——边界：首先检测局部不连续性，然后将它们连接起来形成边界，这些边界把图像分以不同的区域。这种基于不连续性原理检出物体边缘的方法称为**基于点相关**的分割技术。
  - 两种方法是互补的。有时将它们结合起来，以求得到更好的分割效果。
- 图像分割的基本策略是基于灰度值的两个基本特性：
  - 区域之间的不连续性：
    - 先找到点、线（宽度为1）、边（不定宽度）
    - 再确定区域
  - 区域内部的相似性
    - 通过选择阈值，找到灰度值相似的区域
    - 区域的外轮廓就是对象的边

## 边缘检测

### 点检测

- 用空域的高通滤波器来检测孤立点

![](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E7%82%B9%E6%A3%80%E6%B5%8B.png)

- 若 R = 0 说明被检测区域各点灰度值相同。
- 若 R > T 说明被检测区域响应该高通滤波器，即该检测区域有孤立点。

### 线检测

- 通过比较典型模版的计算值，确认一个点是否在某个方向的线上。

- 设计模版：

  - 模版系数之和为0
  - 感兴趣的方向系数值较大

  ![](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E7%BA%BF%E6%A3%80%E6%B5%8B.png)

- 用不同模版分别计算，从这些值中寻找绝对值最大值，确定当前点更加接近于该模版所对应的直线。

### 边缘检测

- 物体的边缘是以图像局部特性的不连续性的形式出现的，从本质上说，边缘意味着一个区域的终结和另一个区域的开始。
- 图像边缘信息在图像分析和人的视觉中都是十分重要的，是图像识别中提取图像特征的一个重要属性。

#### 边缘导数

边缘上的这种变化可以通过微分算子进行检测：

##### 一阶导数

$$
\frac{\partial f}{\partial x}=f(x+1)-f(x)
$$



- 通过梯度进行计算
- 特点：对于亮的边，边的变化起点是正的，结束是负的。对于暗边，结论相反。常数部分为零。
- 用途：用于检测图像中边的存在。

##### 二阶导数

- 一个二维图像函数的拉普拉斯算子定义为：
  $$
  \nabla ^2f=\frac{\partial^2f}{\partial x^2}+\frac{\partial ^2f}{\partial y^2}
  $$

  - 在x方向上：
    $$
    \frac{\partial ^2f}{\partial x^2}=f(x+1,y)+f(x-1,y)-2f(x,y)
    $$

  - 在y方向上：
    $$
    \frac{\partial ^2f}{\partial y^2}=f(x,y+1)+f(x,y-1)-2f(x,y)
    $$

  - 所以有：
    $$
    \nabla ^2f(x,y)=f(x+1,y)+f(x-1,y)+f(x,y+1)+f(x,y-1)-4f(x,y)
    $$





- 通过拉普拉斯算子来计算

![](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E8%BE%B9%E7%BC%98%E5%AF%BC%E6%95%B0.png)

#### 简单边缘检测方法

- 最早的边缘检测方法都是基于像素的数值导数的，在数字图像中应用差分代替导数运算。

- 差分定义：
  $$
  \Delta_xf(i,j)=f(i,j)-f(i-1,j)\\
  \Delta_yf(i,j)=f(i,j)-f(i,j-1)\\
  $$





- 即使用一阶导数的边缘检测滤波器。

#### 边缘检测问题

- 问题：
  - 图像中存在太多的细节。
  - 图像受到噪声的干扰，不能准确的检测边缘。
- 一个解决方法：在边缘检测之前对图像进行平滑。先用高斯函数进行平滑（对图像进行线性平滑，在数学上是进行卷积）再提出用拉普拉斯算子来代替以减少后期的运算量。

#### Laplacian边缘检测

Laplacian边缘检测——即高斯拉普拉斯(Laplacian of Gaussian，LOG，或Mexican hat，墨西哥草帽 )滤波器。

- Laplacian由于对噪声太敏感，因此一般不单独使用，通常和平滑(Gaussian)高斯滤波器进行结合来进行边缘检测，**即高斯拉普拉斯(Laplacian of Gaussian，LOG，或Mexican hat，墨西哥草帽 )滤波器。**

  ![](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E9%AB%98%E6%96%AF%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF.png)

### Hough变换

Hough(霍夫)变换可以用于将边缘像素连接起来得到边界曲线，它的主要优点在于受噪声和曲线间断的影响较小。

![hough](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/hough.png)

![hough2](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/hough2.png)

![hough3](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/hough3.png)

## 图像分割

### 阈值法

- 图像分割的的经典方法是基于灰度阈值的分割方法。

![阈值1](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E9%98%88%E5%80%BC1.png)

#### 全局阈值

- 全局阈值是指整幅图像使用同一个阈值做分割处理，并产生一个二值图，区分出前景对象和背景。
- 适用于背景和前景对比度大的图像
- 算法实现：
  - 选取一个合适的阈值T，逐行扫描图像
  - 凡灰度级大于T的，颜色置为255；凡灰度级小于T的，颜色置为0。
- 如何选取阈值，以下有人工和自动选取两种方式。

##### 人工阈值

通过人眼的观察，在分析图像直方图的基础上，人工选出合适的阈值。也可也在人工选出阈值后，根据分割效果，不断地交互操作，从而选择出最佳的阈值。

##### 自动阈值——迭代法

- 开始时选择一个阈值作为初始估计值，然后按某种策略不断选择新的阈值。

- 关键在于选什么样的阈值改进策略，好的阈值改进策略应该具备两个特征，一是能够快速收敛，二是在每一次迭代过程中，新产生阈值优于上一次的阈值。

- 基本全局阈值T可以按如下计算：

  ![](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E8%87%AA%E5%8A%A8%E9%98%88%E5%80%BC-%E8%BF%AD%E4%BB%A3.png)

##### 自动阈值——OSTU方法

![](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/ostu.png)

#### 单值阈值的问题

- 只能对双峰的直方图有较好的工作效果。
- 对于其他类型的直方图，需要更多的阈值。
- 不均匀的光照会使单值阈值方案失效。

#### 自动阈值——分水岭算法

![](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E5%88%86%E6%B0%B4%E5%B2%AD1.png)

![](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E5%88%86%E6%B0%B4%E5%B2%AD2.png)

![](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E5%88%86%E6%B0%B4%E5%B2%AD3.png)

![](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E5%88%86%E6%B0%B4%E5%B2%AD4.png)

- 改进的分水岭算法：

  ![](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E5%88%86%E6%B0%B4%E5%B2%AD5.png)

### 区域分割

- 阈值分割法由于没有或很少考虑空间关系，使多阈值选择受到限制
- 基于区域的分割方法可以弥补，它利用的是图像的空间性质，该方法认为分割出来的属性同一区域的像素应具有相似的性质。
- 传统的区域分割算法有区域增长法和区域分割合并法。该类方法在没有先验知识可以利用时，对含有复杂场景或自然景物等先验知识不足的图像进行分割，也可以取得较好的性能。但是，空间和时间开销都比较大。

#### 区域生长

分割的目的是把一副图像划分成一些区域，最直接的方法就是把一幅图像分成满足某种判据的区域，即将点组成区域。为了实现分组，首先要确定区域的数目，其次要确定一个区域与其他区域相区别的特征，最后还要产生有意义分割的相似性判据。

##### 基本思路

![](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E5%8C%BA%E5%9F%9F%E7%94%9F%E9%95%BF.png)

##### 基本步骤

1. 选择合适的种子点
2. 确定相似性准则（生长准则）
3. 确定生长停止条件

##### 过程

- 从满足检测准则的点开始（或者已知点）在各个方向上生长出区域。
- 例如：每一步所接受的邻近点的灰度级与种子点的灰度级**相差绝对值小于等于T**。

![](/Users/yiner/Desktop/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E4%B8%93%E4%B8%9A%E8%AF%BE/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Notes/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F.assets/%E5%8C%BA%E5%9F%9F%E7%94%9F%E9%95%BF2.png)